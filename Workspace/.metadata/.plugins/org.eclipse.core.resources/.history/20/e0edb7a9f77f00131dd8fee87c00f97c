
public class Week11Problem6 {

	public static int[] getPath(int[][] board) {
		return getPath(board, 0, new int[board.length], new int[board.length]);
	}

	public static int[] getPath(int[][] board, int column, int[] path, int[] maxPath) {
		if (board.length == 1) {
			int[] nextC;

			if (column == 0) {nextC = new int[] {column, column + 1};}
			else if (column == board[0].length - 1) {nextC = new int[] {column - 1, column};}
			else {nextC = new int[] {column - 1, column, column + 1};}

			for (int c : nextC) {
				path[path.length - 1] = board[0][c];
				maxPath = arraySum(path) > arraySum(maxPath) ? path : maxPath;
			}

			return maxPath;
		}
		
		int[][] smallBoard = new int[board.length - 1][board[0].length];
		
		for (int i = 1; i < board.length; i ++) {
			smallBoard[i - 1] = board[i].clone();
		}
		
		path[path.length - smallBoard.length] = board[0][column];

		int[] nextC;

		if (column == 0) {nextC = new int[] {column, column + 1};}
		else if (column == board[0].length - 1) {nextC = new int[] {column - 1, column};}
		else {nextC = new int[] {column - 1, column, column + 1};}
		
		for (int c : nextC) {
			path[path.length - smallBoard.length] = smallBoard[0][c]; // The length of path should be equal to the length of the original board, and so it can be used to find the index for the next entry in the path
			maxPath = getPath(smallBoard, c, path, maxPath);
		}

		return maxPath;
	}

	public static int arraySum(int[] array) {
		int sum = 0;

		for (int n : array) {
			sum += n;
		}

		return sum;
	}
	
	public static void main(String[] args){
		int[][] grid = {
				{2, 5, 17, 12, 3},
				{15, 8, 4, 11, 10},
				{9, 18, 6, 20, 16},
				{14, 13, 12, 1, 07}
		};
		
		int[] path = getPath(grid);

		for (int p : path) {
			System.out.println(p);
		}
	}

}
