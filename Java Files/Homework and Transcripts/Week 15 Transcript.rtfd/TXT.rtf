{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf190
{\fonttbl\f0\fnil\fcharset0 Verdana;\f1\fmodern\fcharset0 Courier-Bold;\f2\fmodern\fcharset0 Courier-BoldOblique;
\f3\fswiss\fcharset0 Helvetica;\f4\fmodern\fcharset0 Courier;\f5\fmodern\fcharset0 Courier-Oblique;
\f6\fnil\fcharset0 LucidaGrande;}
{\colortbl;\red255\green255\blue255;\red15\green112\blue1;\red115\green0\blue2;\red18\green139\blue2;
\red0\green0\blue83;\red1\green32\blue135;\red43\green139\blue39;\red83\green83\blue83;\red251\green0\blue7;
\red11\green85\blue38;\red190\green74\blue193;\red0\green0\blue255;\red38\green38\blue38;\red196\green196\blue196;
\red249\green249\blue249;\red11\green86\blue1;\red87\green197\blue83;\red133\green35\blue39;\red154\green151\blue213;
\red109\green109\blue109;\red30\green91\blue156;\red162\green165\blue6;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid401\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid501\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid6}
{\list\listtemplateid7\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid601\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid7}
{\list\listtemplateid8\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid701\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid8}
{\list\listtemplateid9\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid801\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid9}
{\list\listtemplateid10\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid901\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid10}
{\list\listtemplateid11\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1001\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid11}
{\list\listtemplateid12\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid12}
{\list\listtemplateid13\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid13}
{\list\listtemplateid14\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid14}
{\list\listtemplateid15\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1401\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid15}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}{\listoverride\listid7\listoverridecount0\ls7}{\listoverride\listid8\listoverridecount0\ls8}{\listoverride\listid9\listoverridecount0\ls9}{\listoverride\listid10\listoverridecount0\ls10}{\listoverride\listid11\listoverridecount0\ls11}{\listoverride\listid12\listoverridecount0\ls12}{\listoverride\listid13\listoverridecount0\ls13}{\listoverride\listid14\listoverridecount0\ls14}{\listoverride\listid15\listoverridecount0\ls15}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720

\f0\b\fs26 \cf2 dkneezel
\b0 \cf0  
\fs20 7:30:31 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Time to start!
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:30:42 pm
\fs26 \
\pard\pardeftab720

\b \cf3 Java Programming with Data Structures Week 15: Linked Lists
\b0 \cf0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:30:46 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Over the last couple of weeks, we designed an interface to represent a list of Strings. Here it is again:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:30:56 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
public interface AOPSList \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0public \cf5 void\cf0  addToFront\cf4 (\cf6 String\cf0  x\cf4 )\cf7 ;\cf0  
\f2\i \cf8 // puts x on the front of the list
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0public \cf5 void\cf0  addToBack\cf4 (\cf6 String\cf0  x\cf4 )\cf7 ;\cf0  
\f2\i \cf8 // puts x on the back
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0public \cf5 void\cf0  insert\cf4 (\cf6 String\cf0  x, \cf5 int\cf0  position\cf4 )\cf7 ;\cf0  
\f2\i \cf8 // put x into the given position
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0public \cf5 void\cf0  replace\cf4 (\cf6 String\cf0  x, \cf5 int\cf0  position\cf4 )\cf7 ;\cf0  
\f2\i \cf8 // replace given position with x
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0public \cf6 String\cf0  get\cf4 (\cf5 int\cf0  position\cf4 )\cf7 ;\cf0  
\f2\i \cf8 // return String in given position (or "ERROR")
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0public \cf5 int\cf0  size\cf4 ()\cf7 ;\cf0  
\f2\i \cf8 // how many elements are in the list
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0public \cf5 boolean\cf0  isEmpty\cf4 ()\cf7 ;\cf0  
\f2\i \cf8 // are there elements in the list
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0public \cf5 boolean\cf0  contains\cf4 (\cf6 String\cf0  x\cf4 )\cf7 ;\cf0  
\f2\i \cf8 // is x in the list?
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0public \cf5 void\cf0  remove\cf4 (\cf5 int\cf0  position\cf4 )\cf7 ;\cf0  
\f2\i \cf8 // delete the element at given position
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0public \cf5 int\cf0  index\cf4 (\cf6 String\cf0  x\cf4 )\cf7 ;\cf0  
\f2\i \cf8 // returns first position of x in the list, -1 if not there
\f1\i0 \cf0 \
\pard\pardeftab720
\cf4 \}\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 7:31:04 pm
\fs26 \
\pard\pardeftab720

\b \cf0 You can download it from the home page if you haven't already.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:31:14 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We then coded a dynamic array-based class to implement the interface. This week, we'll look at a different approach. So let's get started!
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:31:23 pm
\fs26 \
\pard\pardeftab720

\b \cf3 PART 1: LINKED LISTS
\b0 \cf0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:31:27 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Our AList is a very good data structure, but it has the flaw that resizing the list is relatively expensive. It does not seem to use memory particularly efficiently.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:31:35 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The main problem is the need to keep data in consecutive memory locations. Arrays require this so we can easily access any location in it. If we know the location of the first array element, then we know that, say, the element in position 5 is five spaces over from there.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:32:04 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Suppose, instead, we were to remove that restriction and allow a list element to be placed anywhere.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:32:15 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The big question in such a situation is how we then keep track of where all the elements are.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:33:02 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The answer is to have each list element not just remember a piece of data but 
\i also the location (in memory) of the element that follows it
\i0 .
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:33:13 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Here's a picture to illustrate:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:33:14 pm
\fs26 \
\pard\pardeftab720

\b \cf0 \
\pard\pardeftab720

\f3\b0\fs24 \cf0 {{\NeXTGraphic linkedList1.png \width9600 \height5400 \noorient
}¬}\pard\pardeftab720

\f0\fs26 \cf0 \

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:33:18 pm
\fs26 \
\pard\pardeftab720

\b \cf0 In this example, my list consists of four boxes. Each box contains two parts. The left half contains data. Here that data is the letters A, B, C, and D.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:33:27 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The second part contains the link to the next element in the chain. So we see the box with B follows the box with A.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:33:42 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The box for D does not have an arrow coming out of it. The slash in its second part represents a \cf3 null reference\cf0  indicating the end of the list.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:33:49 pm
\fs26 \
\pard\pardeftab720

\b \cf0 I drew these boxes in a row to make the picture manageable, but in principle, I could put the boxes anywhere. It's the arrows that indicate the order of the list.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:33:57 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The arrow labeled "head" points to the first element of the list.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:34:02 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Suppose I want to add the letter X to the beginning of this list. We would need to make a new box with X in it. What arrows would have to change or be added?
\b0 \
\pard\pardeftab720
\cf9 ScottBusche\cf0  
\fs20 7:35:10 pm
\fs26 \
Head to X and X to A.\
\cf9 connor0728\cf0  
\fs20 7:35:10 pm
\fs26 \
arrow from that box to A and from head to X\
\cf9 Tungsten\cf0  
\fs20 7:35:10 pm
\fs26 \
head would point to the box with X in it and the arrow from X would point to A. Nothing else would change.\
\cf9 k77frank\cf0  
\fs20 7:35:10 pm
\fs26 \
the head would start from X, and there would be an array from the X to A\
\cf9 PiCrazy31415\cf0  
\fs20 7:35:10 pm
\fs26 \
head to X, X to A\
\cf9 piis3141592653\cf0  
\fs20 7:35:14 pm
\fs26 \
an arrow pointing from x to a and an arrow from the head to X\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:35:16 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The "head" arrow should point to the new box with X in it. The arrow out of the X box should point to the one with A:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:35:21 pm
\fs26 \
\pard\pardeftab720

\b \cf0 \
\pard\pardeftab720

\f3\b0\fs24 \cf0 {{\NeXTGraphic linkedList2.png \width9600 \height5400 \noorient
}¬}\pard\pardeftab720

\f0\fs26 \cf0 \

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:35:30 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Note that the boxes with A, B, C, and D did not have to move. So we don't have the expense of shifting.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:35:43 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Similarly, suppose you want to delete the box with C in it. What arrows would change?
\b0 \
\pard\pardeftab720
\cf9 spower4\cf0  
\fs20 7:37:14 pm
\fs26 \
the b arrow would go straight to d\
\cf9 chenjamin\cf0  
\fs20 7:37:14 pm
\fs26 \
single arrow from B to D, delete arrows going and coming from C\
\cf9 Tungsten\cf0  
\fs20 7:37:14 pm
\fs26 \
The arrow from B would point to D and C's arrow would disappear.\
\cf9 manbugbeebee\cf0  
\fs20 7:37:14 pm
\fs26 \
arrow from b to c would have to go from b to d instead\
\cf9 PiCrazy31415\cf0  
\fs20 7:37:14 pm
\fs26 \
remove BC, CD, add BD\
\cf9 JRY\cf0  
\fs20 7:37:14 pm
\fs26 \
B to C would go from B to D instead, and C to D would disappear\
\cf9 connor0728\cf0  
\fs20 7:37:14 pm
\fs26 \
arrow from B to D\
\cf9 k77frank\cf0  
\fs20 7:37:14 pm
\fs26 \
arrow would go from B to D indstead\
\cf9 piis3141592653\cf0  
\fs20 7:37:14 pm
\fs26 \
take away the arrows from c to d and b to c, and create a new arrow from b to d\
\cf9 jprosk\cf0  
\fs20 7:37:14 pm
\fs26 \
B to D\
\cf9 puwei99\cf0  
\fs20 7:37:14 pm
\fs26 \
the arrow from b would go to d\
\cf9 PiCrazy31415\cf0  
\fs20 7:37:14 pm
\fs26 \
B points to D\
\cf9 mattpi\cf0  
\fs20 7:37:14 pm
\fs26 \
B would point to D\
\cf9 ScottBusche\cf0  
\fs20 7:37:14 pm
\fs26 \
B to D.\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:37:42 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Only one has to change. The arrow out of B should now point to D :
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:37:45 pm
\fs26 \
\pard\pardeftab720

\b \cf0 \
\pard\pardeftab720

\f3\b0\fs24 \cf0 {{\NeXTGraphic linkedList3.png \width9600 \height5400 \noorient
}¬}\pard\pardeftab720

\f0\fs26 \cf0 \

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:37:52 pm
\fs26 \
\pard\pardeftab720

\b \cf0 C's box is still in my picture, but note nothing points at it. Java has a process called \cf3 garbage collection\cf0  that will go through memory, find objects like C's node that have no references to them, and delete them.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:39:11 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Now if we go through the list, we start at X, go to A, then go to B, then go to D. Again nothing needs to be shifted around.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:39:21 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Questions there?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:39:34 pm
\fs26 \
\pard\pardeftab720

\b \cf3 PART 2: NODES
\b0 \cf0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:39:35 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Let's see how we can code this structure. You should make another class in the same project as your AOPSList interface. We'll call this one LList. Like AList, it should also implement AOPSList.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:40:12 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Let me know when you've done this and are ready to go.
\b0 \
\pard\pardeftab720
\cf9 Tungsten\cf0  
\fs20 7:40:19 pm
\fs26 \
Should I use AOPSList or AOPSListGeneric?\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:40:36 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Use AOPSList. Making the class generic will be a message board problem this week.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:41:23 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Everybody ready?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:42:03 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Okay. I'm going to press on. Let us know if you're having any problems and I'll ask one of the assistants to help you.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:42:06 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The first step is to figure out what those boxes are in my pictures. We're going to make a class for them called Node. This class really only exists to support the LList class, so no other programs should be able to work with it. So we are going to make it a private class inside the LList definition:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:42:30 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
public class LList implements AOPSList \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0private class Node\
\'a0\'a0\'a0\'a0\cf4 \{\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 7:42:37 pm
\fs26 \
\pard\pardeftab720

\b \cf0 As our boxes have two parts, our Node class will have two attributes. The first represents the data in the node. What type should that be here?
\b0 \
\pard\pardeftab720
\cf9 MSTang\cf0  
\fs20 7:43:17 pm
\fs26 \
string\
\cf9 ScottBusche\cf0  
\fs20 7:43:17 pm
\fs26 \
String\
\cf9 JRY\cf0  
\fs20 7:43:17 pm
\fs26 \
String\
\cf9 PiCrazy31415\cf0  
\fs20 7:43:17 pm
\fs26 \
String\
\cf9 connor0728\cf0  
\fs20 7:43:17 pm
\fs26 \
String\
\cf9 spower4\cf0  
\fs20 7:43:17 pm
\fs26 \
String\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:43:21 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Remember we're making a list of Strings, so the data is of type String.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:43:22 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0public \cf6 String\cf0  data\cf7 ;\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 7:43:29 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Notice something strange here?
\b0 \
\pard\pardeftab720
\cf9 chenjamin\cf0  
\fs20 7:44:21 pm
\fs26 \
public?\
\cf9 Tungsten\cf0  
\fs20 7:44:21 pm
\fs26 \
It's public! 
\f3\fs24 {{\NeXTGraphic surprise.gif \width320 \height320 \noorient
}¬}
\f0\fs26 \
\cf9 MSTang\cf0  
\fs20 7:44:21 pm
\fs26 \
The info is public, in a private class\
\cf9 PiCrazy31415\cf0  
\fs20 7:44:21 pm
\fs26 \
variable is public\
\cf9 ScottBusche\cf0  
\fs20 7:44:21 pm
\fs26 \
Public?\
\cf9 JRY\cf0  
\fs20 7:44:21 pm
\fs26 \
the instance variable is public\
\cf9 teachm\cf0  
\fs20 7:44:21 pm
\fs26 \
public in a private?\
\cf9 MathWolf\cf0  
\fs20 7:44:21 pm
\fs26 \
public\
\cf9 MathWolf\cf0  
\fs20 7:44:21 pm
\fs26 \
We made it public\
\cf9 piis3141592653\cf0  
\fs20 7:44:21 pm
\fs26 \
you used public...\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:44:23 pm
\fs26 \
\pard\pardeftab720

\b \cf0 I declared an attribute of a class public instead of private. Why is this OK here?
\b0 \
\pard\pardeftab720
\cf9 chenjamin\cf0  
\fs20 7:46:19 pm
\fs26 \
because it's a private class\
\cf9 Tungsten\cf0  
\fs20 7:46:19 pm
\fs26 \
The class is private, so the data can only be accessed from within LList.\
\cf9 JRY\cf0  
\fs20 7:46:19 pm
\fs26 \
The class is private, so it can't be accessed outside of the file\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:46:20 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The Node class itself is private to LList, and we're the ones writing LList. So there's no reason to hide the internals of Node from LList. We could make setters and getters as usual, but it's simpler to just access the variables directly.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:46:41 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Again don't do this 
\i in general
\i0 . It's really only OK if you have one class that's private to another one.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:47:03 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Now we need the type of the other attribute. What kind of thing is at the other end of each arrow?
\b0 \
\pard\pardeftab720
\cf9 Tungsten\cf0  
\fs20 7:47:26 pm
\fs26 \
The next element\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:47:39 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Sure. And what kind of thing will that be?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:48:10 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Notice that in our pictures, the arrow from one 
\i box
\i0  pointed to another 
\i box
\i0 ...
\b0 \
\pard\pardeftab720
\cf9 MSTang\cf0  
\fs20 7:48:31 pm
\fs26 \
node\
\cf9 spower4\cf0  
\fs20 7:48:31 pm
\fs26 \
the next node\
\cf9 teachm\cf0  
\fs20 7:48:31 pm
\fs26 \
a node\
\cf9 ScottBusche\cf0  
\fs20 7:48:31 pm
\fs26 \
Another Node?\
\cf9 MSTang\cf0  
\fs20 7:48:31 pm
\fs26 \
Node\
\cf9 PiCrazy31415\cf0  
\fs20 7:48:31 pm
\fs26 \
Node\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:48:35 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Each arrow points to a box, which is a Node. So we make Node the type of the other parameter:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:48:40 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0private class Node\
\'a0\'a0\'a0\'a0\cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0public \cf6 String\cf0  data\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0public Node next\cf7 ;\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 7:49:24 pm
\fs26 \
\pard\pardeftab720

\b \cf0 (Sorry for the doubled header of the Node class up there in the stickied region at the top of the classroom screen. I think you get what I mean.)
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:49:27 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Given that we've eliminated the need for setters and getters, what's the only method we need to write for Node?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:50:40 pm
\fs26 \
\pard\pardeftab720

\b \cf0 What is the most fundamental method for any class?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:51:20 pm
\fs26 \
\pard\pardeftab720

\b \cf0 (It's not toString. toString can be important for helping communicate with the user, but it's not the most fundamental.)
\b0 \
\pard\pardeftab720
\cf9 MSTang\cf0  
\fs20 7:51:32 pm
\fs26 \
constructor\
\cf9 MathWolf\cf0  
\fs20 7:51:32 pm
\fs26 \
Constructor\
\cf9 chenjamin\cf0  
\fs20 7:51:32 pm
\fs26 \
constructor\
\cf9 Tungsten\cf0  
\fs20 7:51:32 pm
\fs26 \
A constructor!\
\cf9 spower4\cf0  
\fs20 7:51:32 pm
\fs26 \
constructor\
\cf9 JRY\cf0  
\fs20 7:51:32 pm
\fs26 \
Constructor\
\cf9 connor0728\cf0  
\fs20 7:51:32 pm
\fs26 \
constructor\
\cf9 teachm\cf0  
\fs20 7:51:32 pm
\fs26 \
constructor\
\cf9 chutney\cf0  
\fs20 7:51:32 pm
\fs26 \
constructor\
\cf9 manbugbeebee\cf0  
\fs20 7:51:41 pm
\fs26 \
constructor\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:51:43 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Every class needs a constructor. We'll just make one that takes values for the instance variables and assigns them directly. I built mine using the "Generate constructors" option under the Source menu.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:51:58 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0public Node\cf4 (\cf6 String\cf0  data, Node next\cf4 )\cf0  \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0this.\cf10 data\cf0  \cf7 =\cf0  data\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0this.\cf10 next\cf0  \cf7 =\cf0  next\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 7:52:12 pm
\fs26 \
\pard\pardeftab720

\b \cf0 So here's the entire LList (and Node) class so far for reference:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:52:28 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
public class LList implements AOPSList \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0private class Node\
\'a0\'a0\'a0\'a0\cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0public \cf6 String\cf0  data\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0public Node next\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0public Node\cf4 (\cf6 String\cf0  data, Node next\cf4 )\cf0  \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0this.\cf10 data\cf0  \cf7 =\cf0  data\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0this.\cf10 next\cf0  \cf7 =\cf0  next\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \}\cf0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\
\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\pard\pardeftab720

\f0\b0 \cf9 AkshajK\cf0  
\fs20 7:52:50 pm
\fs26 \
just asking; is there any reason that we are making a linked list class when we could already do so with Java's LinkedList? I don't see the object of making one ourselves (sorry, but I am a very object-oriented programmer)\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:53:06 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Others of your classmates may be wondering this as well, so I'll just answer it for everybody.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:53:45 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We're learning how to write such classes ourselves because this is how you learn how the things you use work, and it's also how you learn to make advances beyond these things that already exist.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:54:03 pm
\fs26 \
\pard\pardeftab720

\b \cf0 If you were taking a course on how cars work, you'd learn how to take apart parts of an engine.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:54:29 pm
\fs26 \
\pard\pardeftab720

\b \cf0 If you were taking a course on woodworking, you'd learn how to build cabinets and boxes and who knows what else.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:55:08 pm
\fs26 \
\pard\pardeftab720

\b \cf0 All the things you'd learn how to build in those courses can be purchased at various stores, but if you want to know how they work, then you need to know how to build them yourself.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:55:23 pm
\fs26 \
\pard\pardeftab720

\b \cf0 It's how you learn the basic principles of the practice.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:55:25 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Now we're ready to create the attributes for the LList class. Our class needs just one. We need to keep track of the first node in the list, in much the same way that the instance variable array in AList referenced the first element of the array.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:55:56 pm
\fs26 \
\pard\pardeftab720

\b \cf0 What was that reference called in my pictures?
\b0 \
\pard\pardeftab720
\cf9 Tungsten\cf0  
\fs20 7:56:39 pm
\fs26 \
head\
\cf9 spower4\cf0  
\fs20 7:56:39 pm
\fs26 \
head\
\cf9 JRY\cf0  
\fs20 7:56:39 pm
\fs26 \
head\
\cf9 puwei99\cf0  
\fs20 7:56:39 pm
\fs26 \
head arrow\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:56:44 pm
\fs26 \
\pard\pardeftab720

\b \cf0 It was called "head". So that's what we'll call the attribute here:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:56:46 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0private Node head\cf7 ;\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 7:58:18 pm
\fs26 \
\pard\pardeftab720

\b \cf0 (This is an attribute for the LList class, so that's going to go somewhere inside LList's class definition. I'd put it before where we defined the Node class.)
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:58:20 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Our AList had an attribute for capacity. Why don't we have one here?
\b0 \
\pard\pardeftab720
\cf9 puwei99\cf0  
\fs20 7:58:52 pm
\fs26 \
because we just point to the next object\
\cf9 JRY\cf0  
\fs20 7:58:52 pm
\fs26 \
the capacity is unlimited\
\cf9 MSTang\cf0  
\fs20 7:58:52 pm
\fs26 \
no need - easy to expand when needed\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:58:54 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Because we can create Nodes anywhere, we can make as any Nodes as we want. Technically it's limited by the size of memory, but we're going to ignore that for our discussion here.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:59:04 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We also had a size attribute with AList. It was necessary because we could have unused spots in the array. But here we'll only create Nodes when we have data to fill them. So the size will be equal to the number of nodes.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:59:16 pm
\fs26 \
\pard\pardeftab720

\b \cf0 That said, having a size attribute can be very useful. One of the message board problems will ask you to add such an attribute, changing the methods accordingly.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 7:59:54 pm
\fs26 \
\pard\pardeftab720

\b \cf0 So far so good? Any questions before we start writing the methods that are going to be demanded by the fact that LList implements AOPSList?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:00:17 pm
\fs26 \
\pard\pardeftab720

\b \cf3 PART 3: THE METHODS
\b0 \cf0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:00:32 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Our first method will be a constructor that makes an empty LList. This means that there are no Nodes in the list to start. So head doesn't refer to anything.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:00:45 pm
\fs26 \
\pard\pardeftab720

\b \cf0 When we want a reference to nothing, we use the special Java keyword \cf3 null\cf0 . So that makes the default constructor:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:00:48 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0public LList\cf4 ()\cf0 \
\'a0\'a0\'a0\'a0\cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0this.\cf10 head\cf0  \cf7 =\cf0  \cf5 null\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 8:01:17 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Be careful that you don't try to treat null as if it were an object. (We discussed this briefly in a question that popped up on the message board this past week.) If you wrote something like:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:01:18 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\pard\pardeftab720
\cf6 System\cf0 .\cf10 out\cf0 .\cf10 println\cf4 (\cf0 this.\cf10 head\cf0 .\cf10 data\cf4 )\cf7 ;\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 8:01:21 pm
\fs26 \
\pard\pardeftab720

\b \cf0 when head is null, there won't be any red lines in the code. However, if you run it, you will get a Null Pointer Exception. There is no data in head to find.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:01:48 pm
\fs26 \
\pard\pardeftab720

\b \cf0 So let's now write a method that will enable us to add a Node with real data. We'll start on the addToFront code.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:01:52 pm
\fs26 \
\pard\pardeftab720

\b \cf0 How did we do addToFront with AList?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:02:34 pm
\fs26 \
\pard\pardeftab720

\b \cf0 This was two weeks ago, so maybe you don't quite recall.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:02:41 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Here's a hint: We did something lazy.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:02:56 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We "passed the buck" so to speak.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:03:24 pm
\fs26 \
\pard\pardeftab720

\b \cf0 (I don't mean "lazy" in a bad way. What we did was good; it saved us extra work.)
\b0 \
\pard\pardeftab720
\cf9 puwei99\cf0  
\fs20 8:03:43 pm
\fs26 \
called the insert function\
\cf9 mattpi\cf0  
\fs20 8:03:43 pm
\fs26 \
insert\
\cf9 piis3141592653\cf0  
\fs20 8:03:43 pm
\fs26 \
insert(0);?\
\cf9 JRY\cf0  
\fs20 8:03:43 pm
\fs26 \
insert(x, 0)\
\cf9 k77frank\cf0  
\fs20 8:03:43 pm
\fs26 \
we used insert\
\cf9 MathWolf\cf0  
\fs20 8:03:43 pm
\fs26 \
Use insert\
\cf9 teachm\cf0  
\fs20 8:03:43 pm
\fs26 \
used insert\
\cf9 ScottBusche\cf0  
\fs20 8:03:43 pm
\fs26 \
We told insert to do the dirty work.\
\cf9 MathWolf\cf0  
\fs20 8:03:43 pm
\fs26 \
Use insert() to the front\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:03:45 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We called the insert method passing it the data and position 0:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:03:47 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0public \cf5 void\cf0  addToFront\cf4 (\cf6 String\cf0  x\cf4 )\cf0  \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0this.\cf10 insert\cf4 (\cf0 x, \cf11 0\cf4 )\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 8:03:51 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Would this work here?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:04:36 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Sure, if we coded insert correctly. However, in a linked list, inserting at the front is very different from inserting anywhere else. Why? Hint: Think about what has to change.
\b0 \
\pard\pardeftab720
\cf9 ScottBusche\cf0  
\fs20 8:05:23 pm
\fs26 \
The arrow from head.\
\cf9 JRY\cf0  
\fs20 8:05:23 pm
\fs26 \
we have to change head\
\cf9 moppr\cf0  
\fs20 8:05:23 pm
\fs26 \
head changes?\
\cf9 Tungsten\cf0  
\fs20 8:05:23 pm
\fs26 \
The head node has to be set to the new data, and the old data goes onto the new node.\
\cf9 piis3141592653\cf0  
\fs20 8:05:23 pm
\fs26 \
the head changes?\
\cf9 chenjamin\cf0  
\fs20 8:05:23 pm
\fs26 \
the head has to change\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:05:26 pm
\fs26 \
\pard\pardeftab720

\b \cf0 In inserting at the front, our head reference changes. For any other position, the contents of a Node change. So the front is a special case.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:05:41 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Let's work out what has to happen to add an element at the front. What do we put this element in?
\b0 \
\pard\pardeftab720
\cf9 teachm\cf0  
\fs20 8:07:18 pm
\fs26 \
a Node\
\cf9 Tungsten\cf0  
\fs20 8:07:18 pm
\fs26 \
A Node.\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:07:53 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The new piece of data we're putting at the front of the list needs a 
\i brand new
\i0  Node. We can't share space with an existing Node; that would erase the value already there.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:08:44 pm
\fs26 \
\pard\pardeftab720

\b \cf0 To make a Node, the Node constructor needs data and the node that comes next. (If you don't believe me, just scroll up and check that's how we wrote the Node constructor.) The data we need to pass in to the constructor is easy. What is it?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:09:32 pm
\fs26 \
\pard\pardeftab720

\b \cf0 By "data" I mean the string we give to the Node to hold for us.
\b0 \
\pard\pardeftab720
\cf9 JRY\cf0  
\fs20 8:10:30 pm
\fs26 \
x\
\cf9 chenjamin\cf0  
\fs20 8:10:30 pm
\fs26 \
x\
\cf9 MSTang\cf0  
\fs20 8:10:30 pm
\fs26 \
the parameter given\
\cf9 spower4\cf0  
\fs20 8:10:30 pm
\fs26 \
x\
\cf9 MathWolf\cf0  
\fs20 8:10:30 pm
\fs26 \
The element to insert\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:11:15 pm
\fs26 \
\pard\pardeftab720

\b \cf0 That's the parameter we called x when we wrote addToFront for AList. Now how about the next node? Where do we get that?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:12:06 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Remember what we said earlier. We want head to point to this new element...
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:13:59 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We get it from the current value of head.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:14:09 pm
\fs26 \
\pard\pardeftab720

\b \cf0 In my example where we added X, the head of the original list was A's node. So X's node ends up pointing to A's node.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:15:29 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Once we have x's node set up, what else do we have to do?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:16:27 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Think of the pictures we had earlier.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:16:50 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We started with
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:16:56 pm
\fs26 \
\pard\pardeftab720

\b \cf0 \
\pard\pardeftab720

\f3\b0\fs24 \cf0 {{\NeXTGraphic 1__#$!@%!#__linkedList1.png \width9600 \height5400 \noorient
}¬}\pard\pardeftab720

\f0\fs26 \cf0 \

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:17:01 pm
\fs26 \
\pard\pardeftab720

\b \cf0 And turned it into
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:17:07 pm
\fs26 \
\pard\pardeftab720

\b \cf0 \
\pard\pardeftab720

\f3\b0\fs24 \cf0 {{\NeXTGraphic 1__#$!@%!#__linkedList2.png \width9600 \height5400 \noorient
}¬}\pard\pardeftab720

\f0\fs26 \cf0 \

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:17:41 pm
\fs26 \
\pard\pardeftab720

\b \cf0 So far we've talked about making the node that holds X and we've said how we'll get the X node to point to the A node.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:17:47 pm
\fs26 \
\pard\pardeftab720

\b \cf0 What else needs to happen?
\b0 \
\pard\pardeftab720
\cf9 puwei99\cf0  
\fs20 8:18:32 pm
\fs26 \
we need to point the head arow to x\
\cf9 MathWolf\cf0  
\fs20 8:18:32 pm
\fs26 \
Make it's head\
\cf9 Tungsten\cf0  
\fs20 8:18:32 pm
\fs26 \
The head node needs to point to the new node,\
\cf9 JRY\cf0  
\fs20 8:18:32 pm
\fs26 \
Make head point to X\
\cf9 k77frank\cf0  
\fs20 8:18:32 pm
\fs26 \
Make the head X\
\cf9 MathWolf\cf0  
\fs20 8:18:32 pm
\fs26 \
Connect it to the head node\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:18:48 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We make head refer to the 
\i new
\i0  node.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:18:55 pm
\fs26 \
\pard\pardeftab720

\b \cf0 So, given this discussion, can you write the code for addToFront? You can do it in one line.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:21:38 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Hint: We want to create a new node that contains the data x and points to the old head. Then we want to make that new node the new head.
\b0 \
\pard\pardeftab720
\cf9 piis3141592653\cf0  
\fs20 8:24:49 pm
\fs26 \
\pard\pardeftab720

\f4 \cf0 \'a0\'a0\'a0\'a0
\f1\b public
\f4\b0  
\f1\b \cf5 void
\f4\b0 \cf0  addToFront\cf4 (\cf6 String\cf0  x\cf4 )\cf0  \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f5\i \cf8 // TODO Auto-generated method stub
\f4\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1\b this
\f4\b0 .\cf10 head\cf0  \cf7 =\cf0  
\f1\b new
\f4\b0  Node\cf4 (\cf0 x,
\f1\b this
\f4\b0 .\cf10 head\cf4 )\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\pard\pardeftab720

\f0 \cf9 MSTang\cf0  
\fs20 8:24:49 pm
\fs26 \
\pard\pardeftab720

\f4 \cf0 head \cf7 =\cf0  
\f1\b new
\f4\b0  Node\cf4 (\cf0 s, head\cf4 )\cf7 ;\cf0  
\f5\i \cf8 //??
\f4\i0 \cf0 \
\pard\pardeftab720

\f0 \cf9 chenjamin\cf0  
\fs20 8:24:49 pm
\fs26 \
\pard\pardeftab720

\f4 \cf0 \'a0\'a0\'a0\'a0
\f1\b public
\f4\b0  
\f1\b \cf5 void
\f4\b0 \cf0  addToFront\cf4 (\cf6 String\cf0  x\cf4 )\cf0 \
\'a0\'a0\'a0\'a0\cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1\b this
\f4\b0 .\cf10 head\cf0  \cf7 =\cf0  
\f1\b new
\f4\b0  Node\cf4 (\cf0 x, 
\f1\b this
\f4\b0 .\cf10 head\cf4 )\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\pard\pardeftab720

\f0\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:24:54 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Here's mine:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:24:56 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0public \cf5 void\cf0  addToFront\cf4 (\cf6 String\cf0  x\cf4 )\cf0  \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0this.\cf10 head\cf0  \cf7 =\cf0  new Node\cf4 (\cf0 x, this.\cf10 head\cf4 )\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 8:25:38 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Note the two uses of this.head. The one on the right of the equals sign is the original value (the A node in our first diagram); our new node (the X node) points at the original first node (the A node). The this.head on the left indicates we change the reference to the new node (the X node).
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:25:53 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Does that make sense? Any questions on that?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:26:33 pm
\fs26 \
\pard\pardeftab720

\b \cf0 What's the running time of this method? Assume N is the size of the list.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:27:36 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Hint: The first thing to ask yourself is whether what we described depends at all on the size of the list.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:27:43 pm
\fs26 \
\pard\pardeftab720

\b \cf0 If it doesn't, then what...?
\b0 \
\pard\pardeftab720
\cf9 MSTang\cf0  
\fs20 8:27:58 pm
\fs26 \
O(1)?\
\cf9 chenjamin\cf0  
\fs20 8:27:58 pm
\fs26 \
O(1)\
\cf9 Tungsten\cf0  
\fs20 8:27:58 pm
\fs26 \
O(1)\
\cf9 k77frank\cf0  
\fs20 8:27:58 pm
\fs26 \
O(1)\
\cf9 MathWolf\cf0  
\fs20 8:27:58 pm
\fs26 \
O(1)\
\cf9 PiCrazy31415\cf0  
\fs20 8:27:58 pm
\fs26 \
O(1)\
\cf9 JRY\cf0  
\fs20 8:27:58 pm
\fs26 \
O(1)\
\cf9 piis3141592653\cf0  
\fs20 8:27:58 pm
\fs26 \
O(1)?\
\cf9 ScottBusche\cf0  
\fs20 8:27:58 pm
\fs26 \
O(1)\
\cf9 teachm\cf0  
\fs20 8:27:58 pm
\fs26 \
O(1)\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:28:02 pm
\fs26 \
\pard\pardeftab720

\b \cf0 It's constant time (O(1)). It doesn't depend on how many elements we have.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:28:26 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Here's a longer version in case it might help you see better how what we wrote works (don't bother putting it in your LList class):
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:28:27 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0public \cf5 void\cf0  addToFront\cf4 (\cf6 String\cf0  x\cf4 )\cf0  \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node newNode \cf7 =\cf0  new Node\cf4 (\cf0 x, \cf5 null\cf4 )\cf7 ;\cf0  
\f2\i \cf8 // make a new node pointing at nothing
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0newNode.\cf10 next\cf0  \cf7 =\cf0  this.\cf10 head\cf7 ;\cf0  
\f2\i \cf8 // have it instead point to head of the list
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0this.\cf10 head\cf0  \cf7 =\cf0  newNode\cf7 ;\cf0  
\f2\i \cf8 // change head to this node
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 8:29:03 pm
\fs26 \
\pard\pardeftab720

\b \cf0 This breaks up what we can do in one line into three. It makes the steps more explicit, but there's no great need to do it this way once you've come to grips with the way we originally wrote it.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:29:10 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The main reason I'm showing it now is to ask this question. Would the following variation work?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:29:11 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0public \cf5 void\cf0  addToFront\cf4 (\cf6 String\cf0  x\cf4 )\cf0  \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node newNode \cf7 =\cf0  new Node\cf4 (\cf0 x, \cf5 null\cf4 )\cf7 ;\cf0  
\f2\i \cf8 // make a new node pointing at nothing
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0this.\cf10 head\cf0  \cf7 =\cf0  newNode\cf7 ;\cf0  
\f2\i \cf8 // change head to this node
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0newNode.\cf10 next\cf0  \cf7 =\cf0  this.\cf10 head\cf7 ;\cf0  
\f2\i \cf8 // have it instead point to head of the list
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\pard\pardeftab720

\f0\b0 \cf9 MSTang\cf0  
\fs20 8:30:34 pm
\fs26 \
no; in line (3) you're setting its reference equal to itself\
\cf9 MathWolf\cf0  
\fs20 8:30:34 pm
\fs26 \
It points to itself\
\cf9 JRY\cf0  
\fs20 8:30:34 pm
\fs26 \
No, because it loses the old value of this.head\
\cf9 ScottBusche\cf0  
\fs20 8:30:34 pm
\fs26 \
It would point to itself--no.\
\cf9 k77frank\cf0  
\fs20 8:30:34 pm
\fs26 \
no\
\cf9 piis3141592653\cf0  
\fs20 8:30:34 pm
\fs26 \
no\
\cf9 Tungsten\cf0  
\fs20 8:30:34 pm
\fs26 \
No. newNode would end up pointing to itself and not the next elements in the list.\
\cf9 k77frank\cf0  
\fs20 8:30:34 pm
\fs26 \
it is not in the right order because this.head would be referring to the wrong thing\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:30:38 pm
\fs26 \
\pard\pardeftab720

\b \cf0 This would be a bad idea. Moving head first means we no longer have a pointer to the original first node. So all of the original data is lost! Since head would refer to newNode, newNode's next reference would point at itself.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:30:47 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The picture looks like this:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:30:48 pm
\fs26 \
\pard\pardeftab720

\b \cf0 \
\pard\pardeftab720

\f3\b0\fs24 \cf0 {{\NeXTGraphic linkedListBadInsert.png \width9600 \height5400 \noorient
}¬}\pard\pardeftab720

\f0\fs26 \cf0 \

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:30:58 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We'll need to be careful that we don't mess up the pointers this way as we do future list operations.
\b0 \
\pard\pardeftab720
\cf9 k77frank\cf0  
\fs20 8:31:14 pm
\fs26 \
lol, nice paint eraser xP\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:31:42 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Why thank you. [Takes a bow.] I pride myself on my artwork. (Actually, Scott made it. 
\f3\b0\fs24 {{\NeXTGraphic smile.gif \width320 \height320 \noorient
}¬}
\f0\b\fs26  )
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:31:47 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Let's try the next insert method to add something to the end of the list. In the AList, we did it by the following:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:31:50 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0public \cf5 void\cf0  addToBack\cf4 (\cf6 String\cf0  x\cf4 )\cf0  \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0this.\cf10 insert\cf4 (\cf0 x,  this.\cf10 size\cf4 )\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 8:31:55 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Does this work in our LList code?
\b0 \
\pard\pardeftab720
\cf9 MathWolf\cf0  
\fs20 8:32:59 pm
\fs26 \
We don't have a size\
\cf9 puwei99\cf0  
\fs20 8:32:59 pm
\fs26 \
no\
\cf9 ScottBusche\cf0  
\fs20 8:32:59 pm
\fs26 \
No, we don't have this.size.\
\cf9 AkshajK\cf0  
\fs20 8:32:59 pm
\fs26 \
no\
\cf9 JRY\cf0  
\fs20 8:32:59 pm
\fs26 \
No, because just by looking at head we don't know what the last element or size are\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:33:01 pm
\fs26 \
\pard\pardeftab720

\b \cf0 No, we don't have a size attribute. If it did, it would be fine. But we're not doing that today, so we'll have to write it from "scratch".
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:33:24 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Take another look at the stickied picture. If I wanted to insert X at the end, it would go where?
\b0 \
\pard\pardeftab720
\cf9 PiCrazy31415\cf0  
\fs20 8:33:55 pm
\fs26 \
after D\
\cf9 ScottBusche\cf0  
\fs20 8:33:55 pm
\fs26 \
D would point to it.\
\cf9 spower4\cf0  
\fs20 8:33:55 pm
\fs26 \
after D\
\cf9 connor0728\cf0  
\fs20 8:33:55 pm
\fs26 \
after D\
\cf9 Tungsten\cf0  
\fs20 8:33:55 pm
\fs26 \
After D\
\cf9 chenjamin\cf0  
\fs20 8:33:58 pm
\fs26 \
after D\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:34:01 pm
\fs26 \
\pard\pardeftab720

\b \cf0 After the node with a D in it. So D's node would then have to point to X's node. What would X's node point at?
\b0 \
\pard\pardeftab720
\cf9 MSTang\cf0  
\fs20 8:34:28 pm
\fs26 \
null\
\cf9 Tungsten\cf0  
\fs20 8:34:28 pm
\fs26 \
null.\
\cf9 JRY\cf0  
\fs20 8:34:28 pm
\fs26 \
Nothing\
\cf9 k77frank\cf0  
\fs20 8:34:28 pm
\fs26 \
null\
\cf9 spower4\cf0  
\fs20 8:34:28 pm
\fs26 \
nothing\
\cf9 PiCrazy31415\cf0  
\fs20 8:34:28 pm
\fs26 \
nothing\
\cf9 puwei99\cf0  
\fs20 8:34:32 pm
\fs26 \
null referene\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:34:34 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Nothing, since it's now at the end of the list. So its next reference is \cf3 null\cf0 . How would the head of the list change?
\b0 \
\pard\pardeftab720
\cf9 PiCrazy31415\cf0  
\fs20 8:35:45 pm
\fs26 \
it won't\
\cf9 chenjamin\cf0  
\fs20 8:35:45 pm
\fs26 \
it wouldn't\
\cf9 Tungsten\cf0  
\fs20 8:35:45 pm
\fs26 \
It wouldn't change.\
\cf9 spower4\cf0  
\fs20 8:35:45 pm
\fs26 \
it would stay the same\
\cf9 k77frank\cf0  
\fs20 8:35:45 pm
\fs26 \
it wouldn't change\
\cf9 JRY\cf0  
\fs20 8:35:45 pm
\fs26 \
It won't\
\cf9 williamyin08\cf0  
\fs20 8:35:45 pm
\fs26 \
It wouldn't\
\cf9 MSTang\cf0  
\fs20 8:35:49 pm
\fs26 \
it wouldn't (unless the list is currently empty)\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:36:26 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Ooh. Good point MSTang. We'll come back to that. For now I'll pretend the list isn't empty, but more like in the diagram we've been working with.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:36:31 pm
\fs26 \
\pard\pardeftab720

\b \cf0 It doesn't change. A is still at the front. D's node is the only one that changes.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:36:33 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Here's a picture:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:36:33 pm
\fs26 \
\pard\pardeftab720

\b \cf0 \
\pard\pardeftab720

\f3\b0\fs24 \cf0 {{\NeXTGraphic linkedListInsertBack.png \width9600 \height5400 \noorient
}¬}\pard\pardeftab720

\f0\fs26 \cf0 \

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:37:09 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Suppose \cf3 end\cf0  is a reference to the last node on the list. (We'll worry about actually figuring out \cf3 end\cf0  shortly. Just take it as given for now.) Can you give me the (one or) two lines of code that put our data x into the list? We need to make the node holding x, and then we must attach that node to the list.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:38:52 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Node D is \cf3 end\cf0  in the diagram I currently have, if that helps you think about what needs to happen.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:39:47 pm
\fs26 \
\pard\pardeftab720

\b \cf0 (That is to say, Node D would be end before we tack on Node X at the back.)
\b0 \
\pard\pardeftab720
\cf9 MathWolf\cf0  
\fs20 8:40:22 pm
\fs26 \
end = new Node(x, null);\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:40:26 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Almost! Not quite.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:40:34 pm
\fs26 \
\pard\pardeftab720

\b \cf0 This is going to kill our node D.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:40:49 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We want the node AFTER Node D to be the new Node.
\b0 \
\pard\pardeftab720
\cf9 MSTang\cf0  
\fs20 8:41:05 pm
\fs26 \
\pard\pardeftab720

\f4 \cf0 end.\cf10 next\cf0  \cf7 =\cf0  
\f1\b new
\f4\b0  Node\cf4 (\cf0 x, 
\f1\b \cf5 null
\f4\b0 \cf4 )\cf7 ;\cf0 \
\pard\pardeftab720

\f0 \cf9 JRY\cf0  
\fs20 8:41:05 pm
\fs26 \
\pard\pardeftab720

\f4 \cf0 end.\cf10 next\cf0  \cf7 =\cf0  
\f1\b new
\f4\b0  Node\cf4 (\cf0 x, 
\f1\b \cf5 null
\f4\b0 \cf4 )\cf7 ;\cf0 \
\pard\pardeftab720

\f0\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:41:14 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Here's my answer in two lines:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:41:17 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node newNode \cf7 =\cf0  new Node\cf4 (\cf0 x, \cf5 null\cf4 )\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0end.\cf10 next\cf0  \cf7 =\cf0  newNode\cf7 ;\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 8:41:39 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Writing it all in one line, \cf3 end.next = new Node(x, null);\cf0 , works too.
\b0 \
\pard\pardeftab720
\cf9 puwei99\cf0  
\fs20 8:41:42 pm
\fs26 \
don't we need to update end?\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:42:24 pm
\fs26 \
\pard\pardeftab720

\b \cf0 No. \cf3 end\cf0  is not an attribute of the LList class. It was just a placeholder name I introduced to help us think about the situation.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:43:03 pm
\fs26 \
\pard\pardeftab720

\b \cf0 For us smart humans it's easy once we know where the last node is. We can tell by looking at the list. But the computer can't do that. So we need to write some code that finds that last box.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:43:05 pm
\fs26 \
\pard\pardeftab720

\b \cf0 How is the last box different from the other boxes?
\b0 \
\pard\pardeftab720
\cf9 MSTang\cf0  
\fs20 8:43:47 pm
\fs26 \
it points to null\
\cf9 PiCrazy31415\cf0  
\fs20 8:43:47 pm
\fs26 \
end.next is null\
\cf9 JRY\cf0  
\fs20 8:43:47 pm
\fs26 \
it has a null reference\
\cf9 spower4\cf0  
\fs20 8:43:47 pm
\fs26 \
it has no reference\
\cf9 MathWolf\cf0  
\fs20 8:43:47 pm
\fs26 \
It's next is null\
\cf9 teachm\cf0  
\fs20 8:43:47 pm
\fs26 \
its value for next is null\
\cf9 Tungsten\cf0  
\fs20 8:43:47 pm
\fs26 \
It has a null reference as the next attribute\
\cf9 k77frank\cf0  
\fs20 8:43:47 pm
\fs26 \
it has a null one\
\cf9 pinkfluffybunnies\cf0  
\fs20 8:43:50 pm
\fs26 \
next=null\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:44:15 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Its \cf3 next\cf0  reference is null. All the other Nodes in the list refer to an actual Node object. So we need to go through the list and find the box with a null next reference.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:44:18 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Here's some code that would let us go through an array:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:44:20 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
for \cf4 (\cf5 int\cf0  j\cf7 =\cf11 0\cf7 ;\cf0  j\cf7 <\cf0 array.\cf10 length\cf7 ;\cf0  j\cf7 ++\cf4 )\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 8:44:21 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Let's think about how to translate this to a linked list. The first part sets a variable to keep track of where we are in the array via its index.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:44:34 pm
\fs26 \
\pard\pardeftab720

\b \cf0 For a linked list, what kind of variable would we use instead of an int?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:45:22 pm
\fs26 \
\pard\pardeftab720

\b \cf0 (To prepare you for the maneuver we're about to do, remember that for loops are just a fancy way of making particular kinds of while loops.)
\b0 \
\pard\pardeftab720
\cf9 chenjamin\cf0  
\fs20 8:45:46 pm
\fs26 \
Node\
\cf9 k77frank\cf0  
\fs20 8:45:46 pm
\fs26 \
Node\
\cf9 JRY\cf0  
\fs20 8:45:46 pm
\fs26 \
Node?\
\cf9 MSTang\cf0  
\fs20 8:45:46 pm
\fs26 \
Node\
\cf9 ScottBusche\cf0  
\fs20 8:45:46 pm
\fs26 \
A Node?\
\cf9 Tungsten\cf0  
\fs20 8:45:46 pm
\fs26 \
Node?\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:46:32 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We would use a Node variable. We keep track via pointers not numbers. (This Node points to the next Node, which points to the next Node, and so forth.) What should our first pointer point at to start?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:47:04 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Well, what's the first Node in our list?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:47:29 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Everybody all together!
\b0 \
\pard\pardeftab720
\cf9 PiCrazy31415\cf0  
\fs20 8:47:41 pm
\fs26 \
head\
\cf9 Tungsten\cf0  
\fs20 8:47:41 pm
\fs26 \
this.head\
\cf9 chenjamin\cf0  
\fs20 8:47:41 pm
\fs26 \
head\
\cf9 spower4\cf0  
\fs20 8:47:41 pm
\fs26 \
head\
\cf9 k77frank\cf0  
\fs20 8:47:41 pm
\fs26 \
head\
\cf9 ScottBusche\cf0  
\fs20 8:47:41 pm
\fs26 \
head\
\cf9 piis3141592653\cf0  
\fs20 8:47:41 pm
\fs26 \
HEAD\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:48:01 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The first pointer should point at the the head of the list. So that gives us:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:48:03 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
Node ptr\cf7 ;\cf0 \
for \cf4 (\cf0 ptr \cf7 =\cf0  this.\cf10 head\cf7 ;\cf0  ___\cf7 ;\cf0  ___\cf4 )\cf0 \
\pard\pardeftab720

\f0\b0 \cf9 Tungsten\cf0  
\fs20 8:48:19 pm
\fs26 \
Why ptr for the name?\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:48:24 pm
\fs26 \
\pard\pardeftab720

\b \cf0 It's short for pointer.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:49:05 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Note that I declared ptr outside the for loop so we can use it in later code. (If I hadn't done that, the ptr variable would be forgotten as soon as the for loop finished.) Let's jump to the third part. For an array, we do j++ or j=j+1 to move to the next position. How do we set ptr to go to the next node?
\b0 \
\pard\pardeftab720
\cf9 PiCrazy31415\cf0  
\fs20 8:49:46 pm
\fs26 \
ptr = ptr.next\
\cf9 JRY\cf0  
\fs20 8:49:46 pm
\fs26 \
ptr = ptr.next\
\cf9 chenjamin\cf0  
\fs20 8:49:46 pm
\fs26 \
ptr = ptr.next;\
\cf9 puwei99\cf0  
\fs20 8:49:46 pm
\fs26 \
ptr = ptr.next\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:49:48 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We write ptr = ptr.next; This changes ptr to refer to the node after ptr.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:49:49 pm
\fs26 \
\pard\pardeftab720

\b \cf0 So, so far we have:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:49:51 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
Node ptr\cf7 ;\cf0 \
for \cf4 (\cf0 ptr\cf7 =\cf0 this.\cf10 head\cf7 ;\cf0  ___\cf7 ;\cf0  ptr \cf7 =\cf0  ptr.\cf10 next\cf4 )\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 8:49:54 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Now we need to decide when to keep repeating. We said before that we need the box whose next reference is null. So ptr has to move forward when we haven't found that node yet. Can you fill in the test?
\b0 \
\pard\pardeftab720
\cf9 MathWolf\cf0  
\fs20 8:50:43 pm
\fs26 \
ptr.next!=null\
\cf9 Tungsten\cf0  
\fs20 8:50:43 pm
\fs26 \
ptr.next != null;\
\cf9 MSTang\cf0  
\fs20 8:50:43 pm
\fs26 \
\pard\pardeftab720

\f4 \cf0 ptr.\cf10 next\cf0  \cf7 !=\cf0  
\f1\b \cf5 null
\f4\b0 \cf0 \
\pard\pardeftab720

\f0 \cf9 PiCrazy31415\cf0  
\fs20 8:50:43 pm
\fs26 \
ptr.next != null\
\cf9 JRY\cf0  
\fs20 8:50:43 pm
\fs26 \
ptr.next != null\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:50:48 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We want ptr.next != null. So that gives us this for loop:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:50:51 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
Node ptr\cf7 ;\cf0 \
for \cf4 (\cf0 ptr\cf7 =\cf0 this.\cf10 head\cf7 ;\cf0  ptr.\cf10 next\cf0  \cf7 !=\cf0  \cf5 null\cf7 ;\cf0  ptr \cf7 =\cf0  ptr.\cf10 next\cf4 )\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 8:51:00 pm
\fs26 \
\pard\pardeftab720

\b \cf0 What do we want to do with the Nodes ptr references as it moves?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:51:44 pm
\fs26 \
\pard\pardeftab720

\b \cf0 In other words, do we need anything in the body of this for loop?
\b0 \
\pard\pardeftab720
\cf9 PiCrazy31415\cf0  
\fs20 8:51:58 pm
\fs26 \
nope\
\cf9 JRY\cf0  
\fs20 8:51:58 pm
\fs26 \
no\
\cf9 Tungsten\cf0  
\fs20 8:51:58 pm
\fs26 \
No.\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:52:11 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We don't need to do anything with them, so the body of our loop can be empty:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:52:14 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
Node ptr\cf7 ;\cf0 \
for \cf4 (\cf0 ptr\cf7 =\cf0 this.\cf10 head\cf7 ;\cf0  ptr.\cf10 next\cf0  \cf7 !=\cf0  \cf5 null\cf7 ;\cf0  ptr \cf7 =\cf0  ptr.\cf10 next\cf4 )\cf7 ;\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 8:52:20 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Note the unusual semicolon following the for loop. That gives our loop an empty body.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:52:22 pm
\fs26 \
\pard\pardeftab720

\b \cf0 When we're done, ptr is at the last node, so we can set end to ptr. Here's the complete code:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:52:29 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0public \cf5 void\cf0  addToBack\cf4 (\cf6 String\cf0  x\cf4 )\cf0  \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node ptr\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0for \cf4 (\cf0 ptr \cf7 =\cf0  this.\cf10 head\cf7 ;\cf0  ptr.\cf10 next\cf0  \cf7 !=\cf0  \cf5 null\cf7 ;\cf0  ptr \cf7 =\cf0  ptr.\cf10 next\cf4 )\cf7 ;\cf0  
\f2\i \cf8 // move through until end
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node end \cf7 =\cf0  ptr\cf7 ;\cf0  \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node newNode \cf7 =\cf0  new Node\cf4 (\cf0 x, \cf5 null\cf4 )\cf7 ;\cf0  
\f2\i \cf8 // make the new node (with nothing after it)
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0end.\cf10 next\cf0  \cf7 =\cf0  newNode\cf7 ;\cf0  
\f2\i \cf8 // old end now points to new node
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\pard\pardeftab720

\f0\b0 \cf9 MSTang\cf0  
\fs20 8:52:41 pm
\fs26 \
You can do a for loop like that??\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:53:08 pm
\fs26 \
\pard\pardeftab720

\b \cf0 You sure can. That's why I paused to make the reminder that for loops are just an idiom for making a particular kind of very common while loop.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:53:13 pm
\fs26 \
\pard\pardeftab720

\b \cf0 This code actually has a potential error. Can you spot it? What would be a bad list to call this on?
\b0 \
\pard\pardeftab720
\cf9 PiCrazy31415\cf0  
\fs20 8:53:50 pm
\fs26 \
empty\
\cf9 piis3141592653\cf0  
\fs20 8:53:50 pm
\fs26 \
empty list\
\cf9 MSTang\cf0  
\fs20 8:53:50 pm
\fs26 \
the empty list (like i said?)\
\cf9 Tungsten\cf0  
\fs20 8:53:50 pm
\fs26 \
An empty list.\
\cf9 ScottBusche\cf0  
\fs20 8:53:50 pm
\fs26 \
Empty?\
\cf9 spower4\cf0  
\fs20 8:53:50 pm
\fs26 \
an empty list\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:53:53 pm
\fs26 \
\pard\pardeftab720

\b \cf0 If the list is empty, we're in trouble. Our ptr will be null, and when we try access ptr.next, we'll get a NullPointerException.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:53:57 pm
\fs26 \
\pard\pardeftab720

\b \cf0 How do we fix this?
\b0 \
\pard\pardeftab720
\cf9 MSTang\cf0  
\fs20 8:55:11 pm
\fs26 \
make this case: ;java if (head == null)\
\cf9 Tungsten\cf0  
\fs20 8:55:11 pm
\fs26 \
Check if this.head is null before we do the rest of the code\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:55:15 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Check for head being null first. If it is, we can call our addToFront method instead, since then the front and the back are the same. Here's the revised method:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:55:22 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0public \cf5 void\cf0  addToBack\cf4 (\cf6 String\cf0  x\cf4 )\cf0  \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0if \cf4 (\cf0 this.\cf10 head\cf0  \cf7 ==\cf0  \cf5 null\cf4 )\cf0  
\f2\i \cf8 // deal with empty list
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0this.\cf10 addToFront\cf4 (\cf0 x\cf4 )\cf7 ;\cf0  
\f2\i \cf8 // put on front
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0else\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node ptr\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0for \cf4 (\cf0 ptr \cf7 =\cf0  this.\cf10 head\cf7 ;\cf0  ptr.\cf10 next\cf0  \cf7 !=\cf0  \cf5 null\cf7 ;\cf0  ptr \cf7 =\cf0  ptr.\cf10 next\cf4 )\cf7 ;\cf0  
\f2\i \cf8 // move through until end
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node end \cf7 =\cf0  ptr\cf7 ;\cf0  \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node newNode \cf7 =\cf0  new Node\cf4 (\cf0 x, \cf5 null\cf4 )\cf7 ;\cf0  
\f2\i \cf8 // make the new node (with nothing after it)
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0end.\cf10 next\cf0  \cf7 =\cf0  newNode\cf7 ;\cf0  
\f2\i \cf8 // old end now points to new node
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\pard\pardeftab720

\f0\b0 \cf9 Tungsten\cf0  
\fs20 8:55:30 pm
\fs26 \
Why do you turn ptr into end? Wouldn't it do the same thing if you just used end as the pointer in the for loop?\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:55:43 pm
\fs26 \
\pard\pardeftab720

\b \cf0 I just did that for code readability.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:55:45 pm
\fs26 \
\pard\pardeftab720

\b \cf0 What's the worst-case running time of the method?
\b0 \
\pard\pardeftab720
\cf9 Tungsten\cf0  
\fs20 8:56:14 pm
\fs26 \
O(N)\
\cf9 MSTang\cf0  
\fs20 8:56:14 pm
\fs26 \
O(N)\
\cf9 PiCrazy31415\cf0  
\fs20 8:56:14 pm
\fs26 \
O(N)\
\cf9 MathWolf\cf0  
\fs20 8:56:14 pm
\fs26 \
O(N)\
\cf9 puwei99\cf0  
\fs20 8:56:14 pm
\fs26 \
O(N)\
\cf9 teachm\cf0  
\fs20 8:56:18 pm
\fs26 \
O(N)\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:56:19 pm
\fs26 \
\pard\pardeftab720

\b \cf0 It moves through every node. That makes it linear time (O(N)).
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:56:21 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Note the contrast between this and the array-based list. In the array, adding to the front was linear (due to shifting the elements down), and adding to the back is constant. It's the opposite with a linked list.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:56:32 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Let's look now at the general insertion method. Here we are given the position where we want to insert the new element.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:56:41 pm
\fs26 \
\pard\pardeftab720

\b \cf0 In our array version, the first thing we did was to check if the position was bad. When would that be the case?
\b0 \
\pard\pardeftab720
\cf9 MSTang\cf0  
\fs20 8:58:38 pm
\fs26 \
if it's not in [0, size]\
\cf9 JRY\cf0  
\fs20 8:58:38 pm
\fs26 \
position < 0 or position > size of list\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:58:41 pm
\fs26 \
\pard\pardeftab720

\b \cf0 If the position is negative, or if the position was greater than the number of elements. We can check the former now, but the latter takes a little more work, since we don't know how many elements we have.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:58:51 pm
\fs26 \
\pard\pardeftab720

\b \cf0 So here's the start of the method to deal with negative positions:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:58:52 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0public \cf5 void\cf0  insert\cf4 (\cf6 String\cf0  x, \cf5 int\cf0  position\cf4 )\cf0  \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0if \cf4 (\cf0 position \cf7 <\cf0  \cf11 0\cf4 )\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0return\cf7 ;\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 8:59:12 pm
\fs26 \
\pard\pardeftab720

\b \cf0 There is another special position number we can deal with now. Which is it?
\b0 \
\pard\pardeftab720
\cf9 Tungsten\cf0  
\fs20 8:59:49 pm
\fs26 \
0\
\cf9 puwei99\cf0  
\fs20 8:59:49 pm
\fs26 \
0\
\cf9 PiCrazy31415\cf0  
\fs20 8:59:49 pm
\fs26 \
0\
\cf9 chenjamin\cf0  
\fs20 8:59:49 pm
\fs26 \
0\
\cf9 MathWolf\cf0  
\fs20 8:59:49 pm
\fs26 \
The front of the list\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:59:52 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Position 0 (i.e. the start of the list) is a special case. Again notice that if we're putting a node at the start, we're not changing any existing nodes. So we'll want to call the addToFront method again:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 8:59:59 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0public \cf5 void\cf0  insert\cf4 (\cf6 String\cf0  x, \cf5 int\cf0  position\cf4 )\cf0  \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0if \cf4 (\cf0 position \cf7 <\cf0  \cf11 0\cf4 )\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0return\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0if \cf4 (\cf0 position \cf7 ==\cf0  \cf11 0\cf4 )\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0this.\cf10 addToFront\cf4 (\cf0 x\cf4 )\cf7 ;\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 9:00:25 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Take a look at my stickied picture again. Suppose we want to insert an element at position 2 in this list. Which existing box(es) should change?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:01:26 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Position 2 means putting the new node (we might as well keep calling it X) between B and C.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:01:35 pm
\fs26 \
\pard\pardeftab720

\b \cf0 So what needs to change?
\b0 \
\pard\pardeftab720
\cf9 Tungsten\cf0  
\fs20 9:02:18 pm
\fs26 \
The pointer from box B\
\cf9 k77frank\cf0  
\fs20 9:02:18 pm
\fs26 \
B to X, X to C\
\cf9 JRY\cf0  
\fs20 9:02:18 pm
\fs26 \
The references of B and X\
\cf9 piis3141592653\cf0  
\fs20 9:02:18 pm
\fs26 \
change bc to bx, and add xc\
\cf9 MathWolf\cf0  
\fs20 9:02:18 pm
\fs26 \
The next of B\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:02:26 pm
\fs26 \
\pard\pardeftab720

\b \cf0 B's node will point at the new node, and the new node points at C's node. Here's a picture:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:02:28 pm
\fs26 \
\pard\pardeftab720

\b \cf0 \
\pard\pardeftab720

\f3\b0\fs24 \cf0 {{\NeXTGraphic linkedListInsertMiddle.png \width9600 \height5400 \noorient
}¬}\pard\pardeftab720

\f0\fs26 \cf0 \

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:02:34 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The important point here is that to insert at position 2, the node at position 
\i 1
\i0  changes. In other words, we need to find the element behind the place where we want to insert.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:02:45 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Again we need to search for it. So we start a pointer at the head of the list and move forward how many times?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:03:53 pm
\fs26 \
\pard\pardeftab720

\b \cf0 I mean in general now. Say we want to insert at the position number \cf3 position\cf0 .
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:04:22 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Remember, we need to modify the node BEFORE the position we want to add the new node at.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:04:35 pm
\fs26 \
\pard\pardeftab720

\b \cf0 (More precisely, we need to modify what that node points at.)
\b0 \
\pard\pardeftab720
\cf9 MSTang\cf0  
\fs20 9:04:53 pm
\fs26 \
position-1\
\cf9 Tungsten\cf0  
\fs20 9:04:53 pm
\fs26 \
position - 1\
\cf9 k77frank\cf0  
\fs20 9:04:53 pm
\fs26 \
position-1\
\cf9 chenjamin\cf0  
\fs20 9:04:53 pm
\fs26 \
move forward position-1 times\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:04:55 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We need to move position-1 times. We can do this with a regular for loop. Something like this:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:05:12 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node ptr \cf7 =\cf0  this.\cf10 head\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0for \cf4 (\cf5 int\cf0  count\cf7 =\cf11 1\cf7 ;\cf0  count\cf7 <\cf0 position\cf7 ;\cf0  count\cf7 ++\cf4 )\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ptr \cf7 =\cf0  ptr.\cf10 next\cf7 ;\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 9:05:13 pm
\fs26 \
\pard\pardeftab720

\b \cf0 There's a problem, though. Can you see it?
\b0 \
\pard\pardeftab720
\cf9 MathWolf\cf0  
\fs20 9:05:47 pm
\fs26 \
What if it goes further than there are Nodes?\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:06:01 pm
\fs26 \
\pard\pardeftab720

\b \cf0 If position is larger than the number of nodes, then eventually \cf3 ptr\cf0  will move off of the end of the list, and we'll get that pesky NullPointerException.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:06:04 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Can you adjust the for loop so it fixes the problem? You'll need to add more to the test.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:08:19 pm
\fs26 \
\pard\pardeftab720

\b \cf0 In particular, you have a problem if \cf3 ptr\cf0  is \cf3 null\cf0 , so what should you test for?
\b0 \
\pard\pardeftab720
\cf9 JRY\cf0  
\fs20 9:08:49 pm
\fs26 \
\pard\pardeftab720

\f4 \cf0 count\cf7 <\cf0 position \cf7 &&\cf0  ptr \cf7 !=\cf0  
\f1\b \cf5 null
\f4\b0 \cf0 \
\pard\pardeftab720

\f0\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:08:52 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We have to also check if ptr is not null before we try to move it forward:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:08:54 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node ptr \cf7 =\cf0  this.\cf10 head\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0for \cf4 (\cf5 int\cf0  count\cf7 =\cf11 1\cf7 ;\cf0  count\cf7 <\cf0 position \cf7 &&\cf0  ptr \cf7 !=\cf0  \cf5 null\cf7 ;\cf0  count\cf7 ++\cf4 )\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ptr \cf7 =\cf0  ptr.\cf10 next\cf7 ;\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 9:09:05 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Does that make sense?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:09:09 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Any questions on that?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:09:43 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Now our loop has two ways to stop. The good way is when we find the node behind where we want to insert. The bad way is if we fall off the end of the list.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:09:52 pm
\fs26 \
\pard\pardeftab720

\b \cf0 How do we know if we ended in the good way?
\b0 \
\pard\pardeftab720
\cf9 teachm\cf0  
\fs20 9:11:18 pm
\fs26 \
see if ptr = null after the loop\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:11:45 pm
\fs26 \
\pard\pardeftab720

\b \cf3 ptr\cf0  will still be in the list. In other words, we can check if ptr is not null. Notice that it is 
\i not
\i0  enough to check if \cf3 count\cf0  is equal to position, since ptr could have just moved one past the end of the list.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:11:47 pm
\fs26 \
\pard\pardeftab720

\b \cf0 So in this case, we want to create the new node and attach it into the list. You've seen some examples of this sort of thing already, so I'll leave it to you to figure out how.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:13:39 pm
\fs26 \
\pard\pardeftab720

\b \cf0 I seem to have lost people.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:14:17 pm
\fs26 \
\pard\pardeftab720

\b \cf0 All that's happening is that we keep moving \cf3 ptr\cf0  forward until one position before the place where we want the new node to be.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:14:32 pm
\fs26 \
\pard\pardeftab720

\b \cf0 (And there was some housekeeping we needed to do to make sure we didn't go too far.)
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:15:27 pm
\fs26 \
\pard\pardeftab720

\b \cf0 But supposing that ptr points to the right node, what do you need to do to make the new node in and make sure everything points where it should? (Similar to other 2- or 1-line insertions we've already written.)
\b0 \
\pard\pardeftab720
\cf9 PiCrazy31415\cf0  
\fs20 9:16:48 pm
\fs26 \
ptr.next = new Node(x, ptr.next)\
\cf9 Tungsten\cf0  
\fs20 9:16:48 pm
\fs26 \
addNode.next = new Node(x, addNode.next);\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:16:51 pm
\fs26 \
\pard\pardeftab720

\b \cf0 I did it in the 2-line way:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:16:53 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node newNode \cf7 =\cf0  new Node\cf4 (\cf0 x, ptr.\cf10 next\cf4 )\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ptr.\cf10 next\cf0  \cf7 =\cf0  newNode\cf7 ;\cf0 \
\pard\pardeftab720

\f0\b0 \cf9 chenjamin\cf0  
\fs20 9:17:00 pm
\fs26 \
\pard\pardeftab720

\f4 \cf0 ptr.\cf10 next\cf0  \cf7 =\cf0  
\f1\b new
\f4\b0  Node\cf4 (\cf0 x, ptr.\cf10 next\cf4 )\cf7 ;\cf0 \
\pard\pardeftab720

\f0\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:17:11 pm
\fs26 \
\pard\pardeftab720

\b \cf0 There's also the 1-line \cf3 ptr.next = new Node(x, ptr.next);
\b0 \cf0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:17:21 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Here's the complete code for the \cf3 insert\cf0  method:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:17:22 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0public \cf5 void\cf0  insert\cf4 (\cf6 String\cf0  x, \cf5 int\cf0  position\cf4 )\cf0  \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0if \cf4 (\cf0 position \cf7 <\cf0  \cf11 0\cf4 )\cf0  
\f2\i \cf8 // negative positions are bad
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0return\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0if \cf4 (\cf0 position \cf7 ==\cf0  \cf11 0\cf4 )\cf0  
\f2\i \cf8 // special case of adding to front
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0this.\cf10 addToFront\cf4 (\cf0 x\cf4 )\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0else\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node ptr \cf7 =\cf0  this.\cf10 head\cf7 ;\cf0  
\f2\i \cf8 // find node behind insertion position
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0for \cf4 (\cf5 int\cf0  count\cf7 =\cf11 1\cf7 ;\cf0  count\cf7 <\cf0 position \cf7 &&\cf0  ptr \cf7 !=\cf0  \cf5 null\cf7 ;\cf0  count\cf7 ++\cf4 )\cf0  
\f2\i \cf8 // count that many nodes or until end of list
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ptr \cf7 =\cf0  ptr.\cf10 next\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0if \cf4 (\cf0 ptr \cf7 !=\cf0  \cf5 null\cf4 )\cf0  
\f2\i \cf8 // if didn't try to move off
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node newNode \cf7 =\cf0  new Node\cf4 (\cf0 x, ptr.\cf10 next\cf4 )\cf7 ;\cf0  
\f2\i \cf8 // insert node at this spot
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ptr.\cf10 next\cf0  \cf7 =\cf0  newNode\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 9:17:31 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Will this method work if the list is empty?
\b0 \
\pard\pardeftab720
\cf9 Tungsten\cf0  
\fs20 9:17:57 pm
\fs26 \
Yes.\
\cf9 MathWolf\cf0  
\fs20 9:17:57 pm
\fs26 \
Yes\
\cf9 k77frank\cf0  
\fs20 9:17:57 pm
\fs26 \
yes\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:18:00 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Yes. The only legal way to insert into an empty list is at position 0, and we have that as a special case. Any other position results in the for loop immediately terminating, since head is null. So ptr will be null, and nothing will happen.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:18:19 pm
\fs26 \
\pard\pardeftab720

\b \cf0 What's the running time of the method?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:18:53 pm
\fs26 \
\pard\pardeftab720

\b \cf0 (What's the worst case?)
\b0 \
\pard\pardeftab720
\cf9 MathWolf\cf0  
\fs20 9:19:16 pm
\fs26 \
O(N)\
\cf9 teachm\cf0  
\fs20 9:19:16 pm
\fs26 \
worst case is O(N)\
\cf9 PiCrazy31415\cf0  
\fs20 9:19:16 pm
\fs26 \
O(N)\
\cf9 JRY\cf0  
\fs20 9:19:16 pm
\fs26 \
O(N)\
\cf9 MSTang\cf0  
\fs20 9:19:16 pm
\fs26 \
O(N)\
\cf9 MathWolf\cf0  
\fs20 9:19:16 pm
\fs26 \
Worst : O(N) Best: O(1)\
\cf9 puwei99\cf0  
\fs20 9:19:16 pm
\fs26 \
O(N)\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:19:19 pm
\fs26 \
\pard\pardeftab720

\b \cf0 It's O(N) worst-case, since we potentially go through all the nodes to find the spot. Recall that the array version was linear too, due to the shifting.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:19:34 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Our next method is \cf3 replace\cf0 . This replaces the String at the given position with x.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:19:44 pm
\fs26 \
\pard\pardeftab720

\b \cf0 This code will be similar to \cf3 insert\cf0 , so let's compare it with what we just wrote. Do we need the check if position is less than zero?
\b0 \
\pard\pardeftab720
\cf9 spower4\cf0  
\fs20 9:20:07 pm
\fs26 \
yes\
\cf9 JRY\cf0  
\fs20 9:20:07 pm
\fs26 \
Yes\
\cf9 PiCrazy31415\cf0  
\fs20 9:20:07 pm
\fs26 \
yes\
\cf9 bluebandit21\cf0  
\fs20 9:20:07 pm
\fs26 \
yes\
\cf9 chenjamin\cf0  
\fs20 9:20:07 pm
\fs26 \
yes\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:20:09 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Yes, that's still bad, and in that case, we again want to return. How about the position=0 case? Is that a special case?
\b0 \
\pard\pardeftab720
\cf9 teachm\cf0  
\fs20 9:20:36 pm
\fs26 \
no\
\cf9 PiCrazy31415\cf0  
\fs20 9:20:36 pm
\fs26 \
no\
\cf9 Tungsten\cf0  
\fs20 9:20:36 pm
\fs26 \
No.\
\cf9 bluebandit21\cf0  
\fs20 9:20:36 pm
\fs26 \
no\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:20:41 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Now it's not, because replacing affects all nodes in the same way. The contents of a box are replaced. There's no need to change the head reference.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:21:04 pm
\fs26 \
\pard\pardeftab720

\b \cf0 So skipping the zero case gives us something like this:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:21:06 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0public \cf5 void\cf0  replace\cf4 (\cf6 String\cf0  x, \cf5 int\cf0  position\cf4 )\cf0  \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0if \cf4 (\cf0 position \cf7 <\cf0  \cf11 0\cf4 )\cf0  
\f2\i \cf8 // negative positions are bad
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0return\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0else\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node ptr \cf7 =\cf0  this.\cf10 head\cf7 ;\cf0  
\f2\i \cf8 // find node behind insertion position
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0for \cf4 (\cf5 int\cf0  count\cf7 =\cf11 1\cf7 ;\cf0  count\cf7 <\cf0 position \cf7 &&\cf0  ptr \cf7 !=\cf0  \cf5 null\cf7 ;\cf0  count\cf7 ++\cf4 )\cf0  
\f2\i \cf8 // count that many nodes or until end of list
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ptr \cf7 =\cf0  ptr.\cf10 next\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0if \cf4 (\cf0 ptr \cf7 !=\cf0  \cf5 null\cf4 )\cf0  
\f2\i \cf8 // if didn't try to move off
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node newNode \cf7 =\cf0  new Node\cf4 (\cf0 x, ptr.\cf10 next\cf4 )\cf7 ;\cf0  
\f2\i \cf8 // insert node at this spot
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ptr.\cf10 next\cf0  \cf7 =\cf0  newNode\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 9:21:14 pm
\fs26 \
\pard\pardeftab720

\b \cf0 What code has to change in the else case?
\b0 \
\pard\pardeftab720
\cf9 puwei99\cf0  
\fs20 9:21:59 pm
\fs26 \
the code inside the if inside the else\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:22:20 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Indeed, that will need to change. Before we do that though, is there anything even before that we'd need to modify?
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:22:44 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Should we still be trying to stop at the node BEFORE the place we want?
\b0 \
\pard\pardeftab720
\cf9 JRY\cf0  
\fs20 9:22:57 pm
\fs26 \
We want to move to position, not position-1\
\cf9 PiCrazy31415\cf0  
\fs20 9:22:57 pm
\fs26 \
no\
\cf9 Tungsten\cf0  
\fs20 9:22:57 pm
\fs26 \
No.\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:23:01 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The first thing is that we have to change the for loop. Now we want to stop at position, not position-1. How do we fix the for loop?
\b0 \
\pard\pardeftab720
\cf9 teachm\cf0  
\fs20 9:24:09 pm
\fs26 \
make count 0, not 1\
\cf9 JRY\cf0  
\fs20 9:24:09 pm
\fs26 \
count <= position\
\cf9 chenjamin\cf0  
\fs20 9:24:09 pm
\fs26 \
count <=position\
\cf9 PiCrazy31415\cf0  
\fs20 9:24:09 pm
\fs26 \
count <= position\
\cf9 Tungsten\cf0  
\fs20 9:24:12 pm
\fs26 \
Change < to <=.\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:24:43 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The simplest way is to change the initialization of count from 1 to 0. You could also change the test to compare with position+1 instead of position, or change the strict inequality (<) to a weak inequality (<
\f3\b0\fs24 {{\NeXTGraphic 1__#$!@%!#__smile.gif \width320 \height320 \noorient
}¬}
\f0\b\fs26 . The rest of the for loop including its body can remain the same.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:24:44 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The second thing is to change what happens when ptr is not null. Can you tell me the line of code we need to actually do the required replacement?
\b0 \
\pard\pardeftab720
\cf9 JRY\cf0  
\fs20 9:25:37 pm
\fs26 \
ptr.data = x instead of ptr = ptr.next\
\cf9 PiCrazy31415\cf0  
\fs20 9:25:37 pm
\fs26 \
ptr.data = x\
\cf9 Tungsten\cf0  
\fs20 9:25:37 pm
\fs26 \
changeNode.data = x;\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:25:40 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We just set ptr.data = x. So here's the whole method:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:25:41 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0public \cf5 void\cf0  replace\cf4 (\cf6 String\cf0  x, \cf5 int\cf0  position\cf4 )\cf0  \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0if \cf4 (\cf0 position \cf7 <\cf0  \cf11 0\cf4 )\cf0  
\f2\i \cf8 // negative positions are bad
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0return\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0else\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node ptr \cf7 =\cf0  this.\cf10 head\cf7 ;\cf0  
\f2\i \cf8 // find node behind insertion position
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0for \cf4 (\cf5 int\cf0  count\cf7 =\cf11 0\cf7 ;\cf0  count\cf7 <\cf0 position \cf7 &&\cf0  ptr \cf7 !=\cf0  \cf5 null\cf7 ;\cf0  count\cf7 ++\cf4 )\cf0  
\f2\i \cf8 // count that many nodes or until end of list
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ptr \cf7 =\cf0  ptr.\cf10 next\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0if \cf4 (\cf0 ptr \cf7 !=\cf0  \cf5 null\cf4 )\cf0  
\f2\i \cf8 // if didn't try to move off
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0   ptr.\cf10 data\cf0  \cf7 =\cf0  x\cf7 ;\cf0  
\f2\i \cf8 // put x into node
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 9:25:53 pm
\fs26 \
\pard\pardeftab720

\b \cf0 I'll ask the same two questions as for insert. Does it work on an empty list?
\b0 \
\pard\pardeftab720
\cf9 spower4\cf0  
\fs20 9:26:35 pm
\fs26 \
yes\
\cf9 JRY\cf0  
\fs20 9:26:35 pm
\fs26 \
yes\
\cf9 Tungsten\cf0  
\fs20 9:26:35 pm
\fs26 \
Yes.\
\cf9 PiCrazy31415\cf0  
\fs20 9:26:35 pm
\fs26 \
yes\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:26:40 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Yes, for the same reason. head will be null, so the loop doesn't run at all, and the if's body does not execute.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:26:44 pm
\fs26 \
\pard\pardeftab720

\b \cf0 What's the running time?
\b0 \
\pard\pardeftab720
\cf9 PiCrazy31415\cf0  
\fs20 9:28:08 pm
\fs26 \
O(N)\
\cf9 Tungsten\cf0  
\fs20 9:28:08 pm
\fs26 \
O(N)\
\cf9 spower4\cf0  
\fs20 9:28:08 pm
\fs26 \
O(N)\
\cf9 piis3141592653\cf0  
\fs20 9:28:08 pm
\fs26 \
O(n)\
\cf9 JRY\cf0  
\fs20 9:28:08 pm
\fs26 \
O(N)\
\cf9 ReciterOfPi\cf0  
\fs20 9:28:08 pm
\fs26 \
O(N) where N is position.\
\cf9 piis3141592653\cf0  
\fs20 9:28:08 pm
\fs26 \
O(N)\
\cf9 MathWolf\cf0  
\fs20 9:28:08 pm
\fs26 \
O(N)\
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:29:21 pm
\fs26 \
\pard\pardeftab720

\b \cf0 I would typically expect N to represent the size of the list, but I suppose ReciterOfPi makes a good point that this method does happen to be precisely O(the position).
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:30:12 pm
\fs26 \
\pard\pardeftab720

\b \cf0 (Assuming the position doesn't take you beyond the end of the list.)
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:30:14 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Next comes get. Remember that, in this version, we return "ERROR" if the position is invalid. Otherwise, we return the value at that position.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:31:02 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Can you write this method? You can cut and paste the code for replace and modify it slightly.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:31:07 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Actually, it's time to stop.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:31:13 pm
\fs26 \
\pard\pardeftab720

\b \cf0 I'll post my answer for this one.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:31:15 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Here's my answer:
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:31:16 pm
\fs26 \
\pard\pardeftab720

\f1\b \cf0 \'a0\
\'a0\'a0\'a0\'a0public \cf6 String\cf0  get\cf4 (\cf5 int\cf0  position\cf4 )\cf0  \cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\i \cf8 // TODO Auto-generated method stub
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0if \cf4 (\cf0 position \cf7 <\cf0  \cf11 0\cf4 )\cf0  
\f2\i \cf8 // negative positions are bad
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0return \cf12 "ERROR"\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0else\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Node ptr \cf7 =\cf0  this.\cf10 head\cf7 ;\cf0  
\f2\i \cf8 // find node behind insertion position
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0for \cf4 (\cf5 int\cf0  count\cf7 =\cf11 0\cf7 ;\cf0  count\cf7 <\cf0 position \cf7 &&\cf0  ptr \cf7 !=\cf0  \cf5 null\cf7 ;\cf0  count\cf7 ++\cf4 )\cf0  
\f2\i \cf8 // count that many nodes or until end of list
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ptr \cf7 =\cf0  ptr.\cf10 next\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0if \cf4 (\cf0 ptr \cf7 !=\cf0  \cf5 null\cf4 )\cf0  
\f2\i \cf8 // if didn't try to move off
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \{\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0   return ptr.\cf10 data\cf7 ;\cf0  
\f2\i \cf8 // extract data from node
\f1\i0 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0else\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0return \cf12 "ERROR"\cf7 ;\cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\'a0\'a0\'a0\'a0\cf4 \}\cf0 \
\pard\pardeftab720

\f0 \cf2 dkneezel
\b0 \cf0  
\fs20 9:31:30 pm
\fs26 \
\pard\pardeftab720

\b \cf0 In the negative position case, we return the error string. In the inner if statement, we either return the data in the node we're pointing at or the error string.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:31:41 pm
\fs26 \
\pard\pardeftab720

\b \cf0 The running time is linear, of course. It's another method where the array version is faster.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:32:17 pm
\fs26 \
\pard\pardeftab720

\b \cf0 I'll post discussion of the last few methods tonight or tomorrow in a new thread on the message board.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:32:18 pm
\fs26 \
\pard\pardeftab720

\b \cf3 PART 5: SUMMARY
\b0 \cf0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:32:19 pm
\fs26 \
\pard\pardeftab720

\b \cf0 This week, we discussed a variation on lists called a linked list. Its main advantage is that values in the list can be stored anywhere in memory.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:32:23 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We saw that a linked list is made up of nodes. A node contains data and a reference to the following node.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:32:25 pm
\fs26 \
\pard\pardeftab720

\b \cf0 We then coded the methods of the AOPSList interface and analyzed their running times.
\b0 \
\pard\pardeftab720

\b \cf2 dkneezel
\b0 \cf0  
\fs20 9:32:35 pm
\fs26 \
\pard\pardeftab720

\b \cf0 Next week, we will look at two more variations on the lists: stacks and queues. These will use different interfaces, as we want to optimize them for certain important operations.\
\
\pard\pardeftab720

\b0\fs24 \cf0 Recall that the methods in the AOPSList interface are\
\
\pard\pardeftab720

\f6\b\fs18 \cf13 \cb14 Code:
\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0
\f1\b\fs24 \cf0 \cb15 {\listtext	1.	}public
\f4\b0 \cf16  
\f1\b \cf0 interface
\f4\b0 \cf16  AOPSList \cf17 \{\cf16 \
{\listtext	2.	}\'a0 \'a0 
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 void\cf16  addToFront\cf17 ({\field{\*\fldinst{HYPERLINK "http://www.google.com/search?hl=en&q=allinurl%3AString+java.sun.com&btnI=I%27m%20Feeling%20Lucky"}}{\fldrslt 
\f1\b \cf19 String}}\cf16  x\cf17 )\cf16 ; 
\f5\i \cf20 // puts x on the front of the list
\f4\i0 \cf16 \
{\listtext	3.	}\'a0 \'a0 
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 void\cf16  addToBack\cf17 ({\field{\*\fldinst{HYPERLINK "http://www.google.com/search?hl=en&q=allinurl%3AString+java.sun.com&btnI=I%27m%20Feeling%20Lucky"}}{\fldrslt 
\f1\b \cf19 String}}\cf16  x\cf17 )\cf16 ; 
\f5\i \cf20 // puts x on the back
\f4\i0 \cf16 \
{\listtext	4.	}\'a0 \'a0 
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 void\cf16  insert\cf17 ({\field{\*\fldinst{HYPERLINK "http://www.google.com/search?hl=en&q=allinurl%3AString+java.sun.com&btnI=I%27m%20Feeling%20Lucky"}}{\fldrslt 
\f1\b \cf19 String}}\cf16  x, \cf18 int\cf16  position\cf17 )\cf16 ; 
\f5\i \cf20 // put x into the given position
\f4\i0 \cf16 \
{\listtext	5.	}\'a0 \'a0 
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 void\cf16  replace\cf17 ({\field{\*\fldinst{HYPERLINK "http://www.google.com/search?hl=en&q=allinurl%3AString+java.sun.com&btnI=I%27m%20Feeling%20Lucky"}}{\fldrslt 
\f1\b \cf19 String}}\cf16  x, \cf18 int\cf16  position\cf17 )\cf16 ; 
\f5\i \cf20 // replace given position with x
\f4\i0 \cf16 \
{\listtext	6.	}\'a0 \'a0 
\f1\b \cf0 public
\f4\b0 \cf16  {\field{\*\fldinst{HYPERLINK "http://www.google.com/search?hl=en&q=allinurl%3AString+java.sun.com&btnI=I%27m%20Feeling%20Lucky"}}{\fldrslt 
\f1\b \cf19 String}} get\cf17 (\cf18 int\cf16  position\cf17 )\cf16 ; 
\f5\i \cf20 // return String in given position (or "ERROR")
\f4\i0 \cf16 \
{\listtext	7.	}\'a0 \'a0 
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 int\cf16  size\cf17 ()\cf16 ; 
\f5\i \cf20 // how many elements are in the list
\f4\i0 \cf16 \
{\listtext	8.	}\'a0 \'a0 
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 boolean\cf16  isEmpty\cf17 ()\cf16 ; 
\f5\i \cf20 // are there elements in the list
\f4\i0 \cf16 \
{\listtext	9.	}\'a0 \'a0 
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 boolean\cf16  contains\cf17 ({\field{\*\fldinst{HYPERLINK "http://www.google.com/search?hl=en&q=allinurl%3AString+java.sun.com&btnI=I%27m%20Feeling%20Lucky"}}{\fldrslt 
\f1\b \cf19 String}}\cf16  x\cf17 )\cf16 ; 
\f5\i \cf20 // is x in the list?
\f4\i0 \cf16 \
{\listtext	10.	}\'a0 \'a0 
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 void\cf16  remove\cf17 (\cf18 int\cf16  position\cf17 )\cf16 ; 
\f5\i \cf20 // delete the element at given position
\f4\i0 \cf16 \
{\listtext	11.	}\'a0 \'a0 
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 int\cf16  index\cf17 ({\field{\*\fldinst{HYPERLINK "http://www.google.com/search?hl=en&q=allinurl%3AString+java.sun.com&btnI=I%27m%20Feeling%20Lucky"}}{\fldrslt 
\f1\b \cf19 String}}\cf16  x\cf17 )\cf16 ; 
\f5\i \cf20 // returns first position of x in the list, -1 if not there
\f4\i0 \cf16 \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0\cf17 {\listtext	12.	}\}\cf16 \
\pard\pardeftab720

\f0 \cf0 \cb1 \
\
At the end of class, we wrote everything up to the 
\b get
\b0  method. We now pick up with the 
\b size
\b0  method.\
\
\pard\pardeftab720

\b \cf0 If you read nothing else in this post, make sure to read the few short paragraphs about 
\i short circuit evaluation
\i0 , as that's a feature of Java (and many other {\field{\*\fldinst{HYPERLINK "http://en.wikipedia.org/wiki/Short-circuit_evaluation#Support_in_common_programming_languages"}}{\fldrslt \cf21 popular programming languages}}) which is just another tool in your toolkit to write clean, efficient code, but can also be the source of some hard-to-find bugs if you don't know about it.
\b0 \
\
Next comes size returning the number of elements in the list. Since we decided not to keep track of the size as one of the fields in the LList class, we'll have to calculate it ourselves. Fortunately, it's a simple adaptation of the code we've been working with. Can you see how to adjust our for loop from replace/get so count ends up being the size of the list?\
\
We just remove the part of the test based on position. Then count keeps going up until the ptr falls off the end of the list.\
\
\pard\pardeftab720

\f6\b\fs18 \cf13 \cb14 Code:
\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls2\ilvl0
\f4\fs24 \cf16 \cb15 {\listtext	1.	}\'a0 \'a0
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 int\cf16  size\cf17 ()\cf16  \cf17 \{\cf16 \
{\listtext	2.	}\'a0 \'a0 \'a0 \'a0 Node ptr = 
\f1\b \cf0 this
\f4\b0 \cf16 .head; 
\f5\i \cf20 // find node behind insertion position
\f4\i0 \cf16 \
{\listtext	3.	}\'a0 \'a0 \'a0 \'a0 \cf18 int\cf16  count;\
{\listtext	4.	}\'a0 \'a0 \'a0 \'a0 \cf22 for\cf16  \cf17 (\cf16 count=\cf11 0\cf16 ; ptr != 
\f1\b \cf0 null
\f4\b0 \cf16 ; count++\cf17 )\cf16  
\f5\i \cf20 // count until end of list
\f4\i0 \cf16 \
{\listtext	5.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 ptr = ptr.next;\
{\listtext	6.	}\'a0 \'a0 \'a0 \'a0 
\f1\b \cf0 return
\f4\b0 \cf16  count;\
{\listtext	7.	}\'a0 \'a0 \cf17 \}\cf16 \
\pard\pardeftab720

\f0 \cf0 \cb1 \
\
Notice that since I need to use count outside the for loop, I need to make sure it's declared outside too.\
\
It may look a little weird to have the variable tested in the for loop be different from the ones in the initialization and increment parts. We can rewrite this:\
\
\pard\pardeftab720

\f6\b\fs18 \cf13 \cb14 Code:
\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls3\ilvl0
\f4\fs24 \cf16 \cb15 {\listtext	1.	}\'a0 \'a0
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 int\cf16  size\cf17 ()\cf16  \cf17 \{\cf16 \
{\listtext	2.	}\'a0 \'a0 \'a0 \'a0 \cf18 int\cf16  count=\cf11 0\cf16 ;\
{\listtext	3.	}\'a0 \'a0 \'a0 \'a0 \cf22 for\cf16  \cf17 (\cf16 Node ptr = 
\f1\b \cf0 this
\f4\b0 \cf16 .head; ptr != 
\f1\b \cf0 null
\f4\b0 \cf16 ; ptr = ptr.next\cf17 )\cf16  
\f5\i \cf20 // count until end of list
\f4\i0 \cf16 \
{\listtext	4.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 count++;\
{\listtext	5.	}\'a0 \'a0 \'a0 \'a0 
\f1\b \cf0 return
\f4\b0 \cf16  count;\
{\listtext	6.	}\'a0 \'a0 \cf17 \}\cf16 \
\pard\pardeftab720

\f0 \cf0 \cb1 \
\
The running time is linear again. That's best case, since there's no way to stop early.\
\
Next: isEmpty. Here's one way we could write it:\
\
\pard\pardeftab720

\f6\b\fs18 \cf13 \cb14 Code:
\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls4\ilvl0
\f4\fs24 \cf16 \cb15 {\listtext	1.	}\'a0 \'a0
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 boolean\cf16  isEmpty\cf17 ()\cf16  \cf17 \{\cf16 \
{\listtext	2.	}\'a0 \'a0 \'a0 \'a0 
\f1\b \cf0 return
\f4\b0 \cf16  
\f1\b \cf0 this
\f4\b0 \cf16 .size\cf17 ()\cf16  == \cf11 0\cf16 ;\
{\listtext	3.	}\'a0 \'a0 \cf17 \}\cf16 \
\pard\pardeftab720

\f0 \cf0 \cb1 \
\
This is perfectly correct, but what's its running time?\
\
Even though it's just one line, that line calls size, which takes linear time. So this version is linear.\
\
We can do better! This one runs in constant time:\
\
\pard\pardeftab720

\f6\b\fs18 \cf13 \cb14 Code:
\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls5\ilvl0
\f4\fs24 \cf16 \cb15 {\listtext	1.	}\'a0 
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 boolean\cf16  isEmpty\cf17 ()\cf16  \cf17 \{\cf16 \
{\listtext	2.	}\'a0 \'a0 \'a0 \'a0 
\f1\b \cf0 return
\f4\b0 \cf16  
\f1\b \cf0 this
\f4\b0 \cf16 .head == 
\f1\b \cf0 null
\f4\b0 \cf16 ;\
{\listtext	3.	}\'a0 \'a0 \cf17 \}\cf16 \
\pard\pardeftab720

\f0 \cf0 \cb1 \
\
One reference to check, and we're done!\
\
For contains, we can do the same approach as with AList. How did we do it?\
\
We called the index method to see where it is. If the index wasn't -1, we know it isn't there:\
\
\pard\pardeftab720

\f6\b\fs18 \cf13 \cb14 Code:
\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls6\ilvl0
\f4\fs24 \cf16 \cb15 {\listtext	1.	}\'a0 \'a0
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 boolean\cf16  contains\cf17 ({\field{\*\fldinst{HYPERLINK "http://www.google.com/search?hl=en&q=allinurl%3AString+java.sun.com&btnI=I%27m%20Feeling%20Lucky"}}{\fldrslt 
\f1\b \cf19 String}}\cf16  x\cf17 )\cf16  \cf17 \{\cf16 \
{\listtext	2.	}\'a0 \'a0 \'a0 \'a0 
\f1\b \cf0 return
\f4\b0 \cf16  
\f1\b \cf0 this
\f4\b0 \cf16 .index\cf17 (\cf16 x\cf17 )\cf16  != \cf11 -1\cf16 ;\
{\listtext	3.	}\'a0 \'a0 \cf17 \}\cf16 \
\pard\pardeftab720

\f0 \cf0 \cb1 \
\
Let's jump ahead and write index. The code is trickier, but again we can leverage the code from replace/get/size to solve it. Instead of using count to decide when to stop, we'll be incrementing it until the ptr is referencing the node with x in it. Can you write the code that does that part?\
\
Here's a short-looking (but incomplete) version:\
\
\pard\pardeftab720

\f6\b\fs18 \cf13 \cb14 Code:
\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls7\ilvl0
\f4\fs24 \cf16 \cb15 {\listtext	1.	}\'a0 \'a0
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 int\cf16  index\cf17 ({\field{\*\fldinst{HYPERLINK "http://www.google.com/search?hl=en&q=allinurl%3AString+java.sun.com&btnI=I%27m%20Feeling%20Lucky"}}{\fldrslt 
\f1\b \cf19 String}}\cf16  x\cf17 )\cf16  \cf17 \{\cf16 \
{\listtext	2.	}\'a0 \'a0 \'a0 \'a0 Node ptr;\
{\listtext	3.	}\'a0 \'a0 \'a0 \'a0 \cf18 int\cf16  count = \cf11 0\cf16 ;\
{\listtext	4.	}\'a0 \'a0 \'a0 \'a0 \cf22 for\cf16  \cf17 (\cf16 ptr = 
\f1\b \cf0 this
\f4\b0 \cf16 .head; ptr != 
\f1\b \cf0 null
\f4\b0 \cf16  && !ptr.data.equals\cf17 (\cf16 x\cf17 )\cf16 ; ptr = ptr.next\cf17 )\cf16 \
{\listtext	5.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 count++; 
\f5\i \cf20 // move until off the end or find the node with x in it
\f4\i0 \cf16 \
\pard\pardeftab720

\f0 \cf0 \cb1 \
\
The for loop starts at the beginning of the list and moves forward until either the pointer falls off the end or it hits the node that has x in it.\
\
We then see which way it turned out by comparing the pointer to null at the end. So here's the whole thing:\
\
\pard\pardeftab720

\f6\b\fs18 \cf13 \cb14 Code:
\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls8\ilvl0
\f4\fs24 \cf16 \cb15 {\listtext	1.	}\'a0 \'a0
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 int\cf16  index\cf17 ({\field{\*\fldinst{HYPERLINK "http://www.google.com/search?hl=en&q=allinurl%3AString+java.sun.com&btnI=I%27m%20Feeling%20Lucky"}}{\fldrslt 
\f1\b \cf19 String}}\cf16  x\cf17 )\cf16  \cf17 \{\cf16 \
{\listtext	2.	}\'a0 \'a0 \'a0 \'a0 Node ptr;\
{\listtext	3.	}\'a0 \'a0 \'a0 \'a0 \cf18 int\cf16  count = \cf11 0\cf16 ;\
{\listtext	4.	}\'a0 \'a0 \'a0 \'a0 \cf22 for\cf16  \cf17 (\cf16 ptr = 
\f1\b \cf0 this
\f4\b0 \cf16 .head; ptr != 
\f1\b \cf0 null
\f4\b0 \cf16  && !ptr.data.equals\cf17 (\cf16 x\cf17 )\cf16 ; ptr = ptr.next\cf17 )\cf16 \
{\listtext	5.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 count++; 
\f5\i \cf20 // move until off the end or find the node with x in it
\f4\i0 \cf16 \
{\listtext	6.	}\'a0 \'a0 \'a0 \'a0 \cf22 if\cf16  \cf17 (\cf16 ptr == 
\f1\b \cf0 null
\f4\b0 \cf17 )\cf16 \
{\listtext	7.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 
\f1\b \cf0 return
\f4\b0 \cf16  \cf11 -1\cf16 ; 
\f5\i \cf20 // not there
\f4\i0 \cf16 \
{\listtext	8.	}\'a0 \'a0 \'a0 \'a0 \cf22 else\cf16 \
{\listtext	9.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 
\f1\b \cf0 return
\f4\b0 \cf16  count; 
\f5\i \cf20 // we have the index
\f4\i0 \cf16 \
{\listtext	10.	}\'a0 \'a0 \cf17 \}\cf16 \
\pard\pardeftab720

\f0 \cf0 \cb1 \
\
Consider this alternative version:\
\
\pard\pardeftab720

\f6\b\fs18 \cf13 \cb14 Code:
\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls9\ilvl0
\f4\fs24 \cf16 \cb15 {\listtext	1.	}\'a0 \'a0
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 int\cf16  index\cf17 ({\field{\*\fldinst{HYPERLINK "http://www.google.com/search?hl=en&q=allinurl%3AString+java.sun.com&btnI=I%27m%20Feeling%20Lucky"}}{\fldrslt 
\f1\b \cf19 String}}\cf16  x\cf17 )\cf16  \cf17 \{\cf16 \
{\listtext	2.	}\'a0 \'a0 \'a0 \'a0 Node ptr;\
{\listtext	3.	}\'a0 \'a0 \'a0 \'a0 \cf18 int\cf16  count = \cf11 0\cf16 ;\
{\listtext	4.	}\'a0 \'a0 \'a0 \'a0 \cf22 for\cf16  \cf17 (\cf16 ptr = 
\f1\b \cf0 this
\f4\b0 \cf16 .head; !ptr.data.equals\cf17 (\cf16 x\cf17 )\cf16  && ptr != 
\f1\b \cf0 null
\f4\b0 \cf16 ; ptr = ptr.next\cf17 )\cf16 \
{\listtext	5.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 count++; 
\f5\i \cf20 // move until off the end or find the node with x in it
\f4\i0 \cf16 \
{\listtext	6.	}\'a0 \'a0 \'a0 \'a0 \cf22 if\cf16  \cf17 (\cf16 ptr == 
\f1\b \cf0 null
\f4\b0 \cf17 )\cf16 \
{\listtext	7.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 
\f1\b \cf0 return
\f4\b0 \cf16  \cf11 -1\cf16 ; 
\f5\i \cf20 // not there
\f4\i0 \cf16 \
{\listtext	8.	}\'a0 \'a0 \'a0 \'a0 \cf22 else\cf16 \
{\listtext	9.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 
\f1\b \cf0 return
\f4\b0 \cf16  count; 
\f5\i \cf20 // we have the index
\f4\i0 \cf16 \
{\listtext	10.	}\'a0 \'a0 \cf17 \}\cf16 \
\pard\pardeftab720

\f0 \cf0 \cb1 \
\
It looks the same, except I swapped the order of the test. Logically, "and" does not depend on the order of the truth values. False and true is the same as true and false. But this code doesn't work. Why not?\
\
If ptr becomes null, we can't check its data. So if x is never found, this will eventually cause a NullPointerException.\
\
Why does it work then in the other direction?\
\
When Java sees that ptr is null, it knows that the test will be false. The second part doesn't matter. So Java does not bother to evaluate it, which means the exception won't happen.\
\
This is called 
\b short circuit evaluation
\b0 . It's very handy in situations where we want to make sure a certain condition holds before we do further tests. It also works for || (or). How would it work there?\
\
For logical "or", if the first part is true, Java doesn't evaluate the second part.\
\
What's the running time of index?\
\
As with many of our other methods, it depends on the location of the element. In the worst case, it's not there, or it's in the last node. In that case, it's linear time.\
\
The next method to do is remove. Suppose we want to remove the element in position 4. Which node or nodes need to change?\
\
The node in position 3 needs to point to the node in position 5. We don't need to change node 4 at all. (Recall the picture from the example earlier in class when we removed C.)\
\
There is one special case we have to worry about, though. Which one?\
\
If we remove position 0, then none of the nodes change, but our head pointer moves to node 1.\
\
So let's start remove by writing the code that checks for this case and adjusts head. Here's the code:\
\
\pard\pardeftab720

\f6\b\fs18 \cf13 \cb14 Code:
\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls10\ilvl0
\f4\fs24 \cf16 \cb15 {\listtext	1.	}\'a0 \'a0
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 void\cf16  remove\cf17 (\cf18 int\cf16  position\cf17 )\cf16  \cf17 \{\cf16 \
{\listtext	2.	}\'a0 \'a0 \'a0 \'a0 \cf22 if\cf16  \cf17 (\cf16 position==\cf11 0\cf17 )\cf16 \
{\listtext	3.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 
\f1\b \cf0 this
\f4\b0 \cf16 .head = 
\f1\b \cf0 this
\f4\b0 \cf16 .head.next;\
{\listtext	4.	}\'a0 \'a0 \'a0 \'a0 \cf22 else\cf16 \
\pard\pardeftab720

\f0 \cf0 \cb1 \
\
head hops forward to the node after what it originally pointed at.\
\
In the else case, we have to find the node 
\b in front of
\b0  the position we want to delete. Here's how I would adjust our looping code from get to handle this:\
\
\pard\pardeftab720

\f6\b\fs18 \cf13 \cb14 Code:
\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls11\ilvl0
\f4\fs24 \cf16 \cb15 {\listtext	1.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0\cf18 int\cf16  count = \cf11 0\cf16 ;\
{\listtext	2.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 Node ptr;\
{\listtext	3.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \cf22 for\cf16  \cf17 (\cf16 ptr = 
\f1\b \cf0 this
\f4\b0 \cf16 .head; ptr != 
\f1\b \cf0 null
\f4\b0 \cf16  && count<position\cf11 -1\cf16 ; ptr = ptr.next\cf17 )\cf16 \
{\listtext	4.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 count++;\
\pard\pardeftab720

\f0 \cf0 \cb1 \
\
Note that the test has position-1. That will have us stop at the correct point.\
\
Now we have to just set ptr's next node to be the one two after it. What assignment does that?\
\
It's ptr.next = ptr.next.next; We do have to be careful that this assignment is legal. What do we need to check?\
\
Clearly ptr can't be null, as in our other examples. But now we also have to make sure that ptr.next isn't null either!\
\
Here's the entire method:\
\
\pard\pardeftab720

\f6\b\fs18 \cf13 \cb14 Code:
\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls12\ilvl0
\f4\fs24 \cf16 \cb15 {\listtext	1.	}\'a0 \'a0@Override\
{\listtext	2.	}\'a0 \'a0 
\f1\b \cf0 public
\f4\b0 \cf16  \cf18 void\cf16  remove\cf17 (\cf18 int\cf16  position\cf17 )\cf16  \cf17 \{\cf16 \
{\listtext	3.	}\'a0 \'a0 \'a0 \'a0 \cf22 if\cf16  \cf17 (\cf16 position==\cf11 0\cf17 )\cf16 \
{\listtext	4.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 
\f1\b \cf0 this
\f4\b0 \cf16 .head = 
\f1\b \cf0 this
\f4\b0 \cf16 .head.next;\
{\listtext	5.	}\'a0 \'a0 \'a0 \'a0 \cf22 else\cf16 \
{\listtext	6.	}\'a0 \'a0 \'a0 \'a0 \cf17 \{\cf16 \
{\listtext	7.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \cf18 int\cf16  count = \cf11 0\cf16 ;\
{\listtext	8.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 Node ptr;\
{\listtext	9.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \cf22 for\cf16  \cf17 (\cf16 ptr = 
\f1\b \cf0 this
\f4\b0 \cf16 .head; ptr != 
\f1\b \cf0 null
\f4\b0 \cf16  && count<position\cf11 -1\cf16 ; ptr = ptr.next\cf17 )\cf16 \
{\listtext	10.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 count++;\
{\listtext	11.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \cf22 if\cf16  \cf17 (\cf16 ptr != 
\f1\b \cf0 null
\f4\b0 \cf16  && ptr.next != 
\f1\b \cf0 null
\f4\b0 \cf17 )\cf16 \
{\listtext	12.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 ptr.next = ptr.next.next;\
{\listtext	13.	}\'a0\
{\listtext	14.	}\'a0 \'a0 \'a0 \'a0 \cf17 \}\cf16 \
{\listtext	15.	}\'a0 \'a0 \cf17 \}\cf16 \
\pard\pardeftab720

\f0 \cf0 \cb1 \
\
What's the running time in this case? That for loop makes it linear. Once we find it, though, it's constant time to perform the actual deletion.\
\
One last method to write, toString. Again we'll use square brackets around the list elements and commas in between.\
\
The algorithm we used last week mostly works. We treat the empty list as a special case. Otherwise, we concatenate each of the first n-1 elements together followed by commas. The last element is followed by a closed bracket.\
\
\pard\pardeftab720

\f6\b\fs18 \cf13 \cb14 Code:
\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls13\ilvl0
\f4\fs24 \cf16 \cb15 {\listtext	1.	}\'a0\
{\listtext	2.	}\'a0 \'a0 
\f1\b \cf0 public
\f4\b0 \cf16  {\field{\*\fldinst{HYPERLINK "http://www.google.com/search?hl=en&q=allinurl%3AString+java.sun.com&btnI=I%27m%20Feeling%20Lucky"}}{\fldrslt 
\f1\b \cf19 String}} toString\cf17 ()\cf16 \
{\listtext	3.	}\'a0 \'a0 \cf17 \{\cf16 \
{\listtext	4.	}\'a0 \'a0 \'a0 \'a0 Node ptr;\
{\listtext	5.	}\'a0 \'a0 \'a0 \'a0 \cf22 if\cf16  \cf17 (
\f1\b \cf0 this
\f4\b0 \cf16 .head == 
\f1\b \cf0 null
\f4\b0 \cf17 )\cf16 \
{\listtext	6.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 
\f1\b \cf0 return
\f4\b0 \cf16  \cf9 "[]"\cf16 ;\
{\listtext	7.	}\'a0 \'a0 \'a0 \'a0 {\field{\*\fldinst{HYPERLINK "http://www.google.com/search?hl=en&q=allinurl%3AString+java.sun.com&btnI=I%27m%20Feeling%20Lucky"}}{\fldrslt 
\f1\b \cf19 String}} answer = \cf9 "["\cf16 ;\
{\listtext	8.	}\'a0 \'a0 \'a0 \'a0 \cf22 for\cf16  \cf17 (\cf16 ptr=
\f1\b \cf0 this
\f4\b0 \cf16 .head; ptr.next != 
\f1\b \cf0 null
\f4\b0 \cf16 ; ptr = ptr.next\cf17 )\cf16 \
{\listtext	9.	}\'a0 \'a0 \'a0 \'a0 \'a0 \'a0 answer += ptr.data+\cf9 ","\cf16 ;\
{\listtext	10.	}\'a0 \'a0 \'a0 \'a0 answer += ptr.data+\cf9 "]"\cf16 ;\
{\listtext	11.	}\'a0 \'a0 \'a0 \'a0 
\f1\b \cf0 return
\f4\b0 \cf16  answer;\
{\listtext	12.	}\'a0 \'a0 \cf17 \}\cf16 \
\pard\pardeftab720

\f0 \cf0 \cb1 \
\
The running time of the method is of course linear.\
\
And there we go! That's all the methods. Here's a summary of the running times, comparing to them to last week's array-based list:\
\
addToFront: O(1) (O(N) for array)\
addToBack: O(N) (O(1) for array, unless you need to resize)\
insert: O(N) worst case (O(N) for array worst-case)\
replace: O(N) worst-case (O(1) for array)\
get: O(N) worst-case (O(1) for array)\
size: O(N), although we could revise the class so this is constant, as in the array\
isEmpty: O(1) (same in array)\
contains: O(N) worst-case (same in array)\
remove: O(N) worst-case (same in array)\
index: O(N) worst-case (same in array)\
toString: O(N) (same in array)\
\
So, in terms of running time, linked lists don\'92t do as well as arrays. Their main benefit is they make 
\i better use of your machine's memory
\i0 .\
\
\pard\pardeftab720

\b \cf0 PART 4: OTHER LIST STUFF
\b0 \
\
Now that we've got the linked list class, let's use it. Pull up last week's NameManager class. Remember it's the one that keeps track of who is in a chatroom.\
\
What do we have to do to change this to work with the LList class we made? The change is in exactly one line. In fact, we change exactly one character!\
\
The line:\
\
\pard\pardeftab720

\f6\b\fs18 \cf13 \cb14 Code:
\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls14\ilvl0
\f4\fs24 \cf16 \cb15 {\listtext	1.	}AOPSList names = 
\f1\b \cf0 new
\f4\b0 \cf16  AList\cf17 ()\cf16 ;\
\pard\pardeftab720

\f0 \cf0 \cb1 \
\
becomes\
\
\pard\pardeftab720

\f6\b\fs18 \cf13 \cb14 Code:
\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls15\ilvl0
\f4\fs24 \cf16 \cb15 {\listtext	1.	}AOPSList names = 
\f1\b \cf0 new
\f4\b0 \cf16  LList\cf17 ()\cf16 ;\
\pard\pardeftab720

\f0 \cf0 \cb1 \
\
Since LList and AList implement the same interface, the same methods will work with either. Hence our code should run exactly as it did before. Try it!\
\
Also, as with AList, we can make a generic version. I'll leave that for you to do on the message board. We would need to use an exception in get rather than return "Error". The exception we created last week will work just fine.\
\
Fortunately, Node does not need to be generic, but we do have to change the instance variable types a little. Which one changes?\
\
data would use the generic type variable. next still refers to a Node.\
\
We've been coding these ourselves to get practice and to better understand how they work. In "real life", we know that Java has an ArrayList already. So it probably wouldn't surprise you to learn that it also has a generic LinkedList class.\
\
ArrayList and LinkedList are both examples of 
\b collections
\b0 . These are data structures designed to hold a group of objects. We can add items to a collection, remove stuff from it, sort the entire collection (put it in order), find the largest element, and do assorted other things.\
\
Specifically, ArrayList and LinkedList implement the generic List interface. This includes many of the methods that we coded ourselves, but with different variations.\
\
For example, our remove method takes out the element at a particular index. The List interface includes a second remove, which deletes the first occurrence of a given element. The List's indexOf is the same as our index. It also includes lastIndexOf to find the final occurrence of a particular value.\
\
Another nice aspect of the LinkedList is that you can use the enhanced for loop with it.\
\
That's all for this week. Tune in next week when we pick up with our next two data structures: Stacks and Queues!}